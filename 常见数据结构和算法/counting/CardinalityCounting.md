# 基数计数（Cardinality Counting）

<pre>
cardinality
n. 基数；集的势
</pre>

## 背景
<p>
基数计数（Cardinality Counting）是实际应用中一种常见的计算场景，在数据分析、网络监控及数据库优化等领域都有相关需求。
</p>
<p>
精确的基数计数算法由于种种原因，在面对大数据场景时往往力不从心，因此如何在误差可控的情况下对基数进行估计就显得十分重要。
</p>
<p>
目前常见的基数估计算法有
<ol>
<li>Linear Counting</li>
<li>LogLog Counting</li>
<li>HyperLogLog Counting</li>
<li>Adaptive Counting</li>
</ol>
等。
</p>
<p>
这几种算法都是基于概率统计理论所设计的概率算法，它们克服了精确基数计数算法的诸多弊端（如内存需求过大或难以合并等），同时可以通过一定手段将误差控制在所要求的范围内。
</p>

## 应用场景举例

<p>例如有10连接，要计算出每个链接被多少个独立用户访问过，即uv计算</p>

### 传统实现思路

1. 标记用户（使用用户id或者cookie跟踪标记每个用户）
2. 给每个链接维护一个visited数组，当用户点击是判断用户是否在visited内，如果不在进行uv加1，并将用户放入visited中。
3. 重要影响因子：visited占用内存的大小以及判断用户是否在visited中的搜索插入；

### 传统实现

1. 使用B树实现visited，B树便于搜索和插入，可以提高搜索插入的效率，但是**占用内存过大**（可定期写到Hbase中），且**不易合并**（例如要计算两个连接的独立用户数）
2. 使用bitmap实现visited，bitmap实现原理为用1存在的位置标识用户，bitmap有效克服了B树无法合并的缺陷，计算两个链接的总uv进行按位或即可，但是bitmap的大小不取决于元素个数的大小，而取决于元素的上限值，因此依旧存在**占用内存过多的问题**；
