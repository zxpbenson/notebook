1
什么是国家？
虽然数据流中的许多操作一次只查看一个单独的事件（例如事件解析器），但有些操作会记住跨多个事件的信息（例如窗口运算符）。这些操作称为有状态操作。
2
有状态操作的一些示例：
3
当应用程序搜索某些事件模式时，状态将存储到目前为止遇到的事件序列。
当聚合每分钟/小时/天的事件时，状态保留挂起的聚合。
在数据点流上训练机器学习模型时，状态保持模型参数的当前版本。
当需要管理历史数据时，状态允许对过去发生的事件进行有效的访问。

Flink需要知道状态，以便使用检查点和保存点使其具有容错性。
4
对状态的了解还允许重新调整Flink应用程序的范围，这意味着Flink负责跨并行实例重新分配状态。
5
Queryable state允许您在运行时从Flink外部访问状态。
6
在处理state时，了解一下Flink的state后端可能也很有用。Flink提供了不同的状态后端，这些后端指定了状态存储的方式和位置。
7
键控状态
Keyed状态被维护在一个可以被认为是一个嵌入的键/值存储区中。状态与有状态运算符读取的流一起被严格地划分和分布。因此，对键/值状态的访问只能在键控流上进行，即在键控/分区数据交换之后，并且仅限于与当前事件的键相关联的值。对齐流和状态的键可以确保所有状态更新都是本地操作，从而保证一致性而不增加事务开销。这种对齐方式还允许Flink重新分配状态并透明地调整流分区。
8
状态和分区
9
键控状态被进一步组织成所谓的密钥组。密钥组是Flink重新分配键控状态的原子单元；密钥组的数量与定义的最大并行性相同。在执行期间，键控运算符的每个并行实例都与一个或多个键组的键一起工作。
10
状态持续性
Flink使用流重放和检查点的组合来实现容错。检查点标记每个输入流中的特定点以及每个运算符的相应状态。流数据流可以从检查点恢复，同时保持一致性（仅一次处理语义），方法是恢复操作符的状态并从检查点重放记录。
11
检查点间隔是一种在执行过程中用恢复时间（需要重放的记录数）来权衡容错开销的一种方法。
12
容错机制连续绘制分布式流数据流的快照。对于状态较小的流式应用程序，这些快照非常轻量级，可以频繁地绘制，而不会对性能造成太大影响。流式应用程序的状态存储在一个可配置的位置，通常是在分布式文件系统中。
13
如果程序失败（由于机器、网络或软件故障），Flink会停止分布式流数据流。然后系统重新启动操作员并将其重置为最新的成功检查点。输入流将重置为状态快照点。作为重新启动的并行数据流的一部分处理的任何记录都不会影响以前的检查点状态。
14
注意，默认情况下禁用检查点。有关如何启用和配置检查点的详细信息，请参阅检查点。
15
注意：为了实现此机制的完全保证，数据流源（如消息队列或代理）需要能够将流倒回到定义的最近点。ApacheKafka有这个能力，Flink的Kafka连接器利用了这个能力。有关Flink连接器提供的保证的更多信息，请参阅数据源和接收器的容错保证。
16
注意，由于Flink的检查点是通过分布式快照实现的，所以我们交替使用snapshot和checkpoint两个词。通常我们也使用术语快照来表示检查点或保存点。
17
检查点
Flink容错机制的核心部分是绘制分布式数据流和操作员状态的一致快照。这些快照充当一致的检查点，在发生故障时，系统可以将其恢复到该检查点。Flink绘制这些快照的机制在“用于分布式数据流的轻量级异步快照”中描述。它的灵感来源于标准的Chandy-Lamport分布式快照算法，并专门针对Flink的执行模型进行了定制。
18
请记住，与检查点相关的所有操作都可以异步完成。检查点屏障不会以锁定步骤移动，操作可以异步快照其状态。
19
障碍
Flink分布式快照的核心元素是流屏障。这些屏障被注入到数据流中，并与作为数据流一部分的记录一起流动。障碍永远不会超过记录，它们严格按照顺序流动。屏障将数据流中的记录分为进入当前快照的记录集和进入下一个快照的记录集。每个屏障都带有快照的ID，它将快照的记录推到它前面。屏障不会中断水流，因此非常轻。来自不同快照的多个屏障可以同时出现在流中，这意味着不同的快照可能同时发生。
20
检查点数据流中的屏障
流屏障被注入流源处的并行数据流中。快照n的屏障被注入的点（我们称之为Sn）是快照覆盖数据的源流中的位置。例如，在apachekafka中，这个位置将是分区中最后一条记录的偏移量。此职位序列号报告给检查点协调员（Flink的作业经理）。
21
然后屏障流向下游。当中间运算符从其所有输入流接收到快照n的屏障时，它将快照n的屏障发射到其所有传出流中。一旦sink操作符（流式DAG的末尾）从其所有输入流接收到barrier n，它就向检查点协调器确认快照n。在所有接收器都确认快照后，即认为快照已完成。
22
一旦快照n完成，作业将不再向源请求Sn之前的记录，因为此时这些记录（及其子记录）将通过整个数据流拓扑。
23
在具有多个输入的运算符处对齐数据流
接收多个输入流的操作员需要在快照屏障上对齐输入流。上图说明了这一点：
24
一旦操作员从传入流接收到快照屏障n，它就不能处理来自该流的任何进一步的记录，直到它也从其他输入接收到屏障n。否则，它将混合属于快照n的记录和属于快照n+1的记录。
报告屏障n的流被暂时搁置。从这些流接收的记录不会被处理，而是被放入输入缓冲区。
一旦最后一个流接收到barrier n，运算符将发出所有挂起的传出记录，然后发出snapshot n barriers本身。
之后，它继续处理来自所有输入流的记录，在处理来自流的记录之前处理来自输入缓冲区的记录。
快照操作员状态
当运算符包含任何形式的状态时，此状态也必须是快照的一部分。
25
当操作员从其输入流接收到所有快照屏障时，以及在将屏障发射到其输出流之前，对其状态进行快照。此时，所有从屏障之前的记录到状态的更新都将被执行，并且没有依赖于屏障应用之后的记录的更新。因为快照的状态可能很大，所以它存储在可配置的状态后端。默认情况下，这是JobManager的内存，但是对于生产使用，应该配置分布式可靠存储（例如HDFS）。存储状态后，操作员确认检查点，将快照屏障发射到输出流中，然后继续。
26
生成的快照现在包含：
27
对于每个并行流数据源，快照启动时流中的偏移量/位置
对于每个运算符，都是指向作为快照一部分存储的状态的指针
检查点机制说明
恢复
此机制下的恢复很简单：一旦发生故障，Flink选择最新完成的检查点k。然后系统重新部署整个分布式数据流，并向每个操作员提供作为检查点k一部分进行快照的状态。源设置为从位置Sk开始读取流。例如，在apachekafka中，这意味着告诉消费者开始从offset Sk获取数据。
28
如果状态是增量快照，则操作员从最新完整快照的状态开始，然后对该状态应用一系列增量快照更新。
29
有关详细信息，请参阅重新启动策略。
30
状态后端
存储键/值索引的确切数据结构取决于所选的状态后端。一个状态后端将数据存储在内存哈希映射中，另一个状态后端使用RocksDB作为键/值存储。除了定义保存状态的数据结构外，状态后端还实现了获取键/值状态的时间点快照的逻辑，并将该快照存储为检查点的一部分。可以在不改变应用程序逻辑的情况下配置状态后端。
31
检查点和快照
32
保存点
所有使用检查点的程序都可以从保存点恢复执行。保存点允许在不丢失任何状态的情况下更新程序和Flink群集。
33
保存点是手动触发的检查点，用于获取程序的快照并将其写入状态后端。它们依赖于常规的检查点机制。
34
保存点类似于检查点，只是它们是由用户触发的，并且在新的检查点完成时不会自动过期。
35
一次对至少一次
对齐步骤可能会增加流式处理程序的延迟。通常，这个额外的延迟大约是几毫秒，但是我们已经看到一些异常值的延迟显著增加的情况。对于所有记录都需要持续超低延迟（几毫秒）的应用程序，Flink有一个开关，可以在检查点期间跳过流对齐。当操作员看到每个输入的检查点屏障时，仍会绘制检查点快照。
36
当跳过对齐时，操作员会继续处理所有输入，即使在检查点n的一些检查点屏障到达之后也是如此。这样，在获取检查点n的状态快照之前，操作符还处理属于检查点n+1的元素。在恢复时，这些记录将作为重复项出现，因为它们都包含在检查点n的状态快照中，并将在检查点n之后作为数据的一部分进行重放。
37
注意：对齐只适用于具有多个前置（联接）的运算符以及具有多个发送者的运算符（在流重新分区/无序处理之后）。因此，只有令人尴尬的并行流操作（map（），flatMap（），filter（），…）的数据流实际上提供了一次保证，即使在至少一次模式下也是如此。
38
批处理程序中的状态与容错
Flink执行批处理程序是流式程序的一种特殊情况，流是有界的（有限个元素）。数据集在内部被视为数据流。因此，上述概念适用于批处理程序的方式与它们适用于流式程序的方式相同，但有一些小的例外：
39
批处理程序的容错不使用检查点。恢复是通过完全重放流来实现的。这是可能的，因为输入是有界的。这使得恢复的成本更高，但由于避免了检查点，所以常规处理更便宜。
40
DataSetAPI中的有状态操作使用简化的内存内/核心外数据结构，而不是键/值索引。
41
数据集API引入了特殊的同步（基于superstep的）迭代，这些迭代只能在有界流上实现。有关详细信息，请查看迭代文档。
