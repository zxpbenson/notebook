# 第八章 函数

## 8.1 概述

<p>一个较大的程序一般应分为若干个子模块，每个模块用来实现一个特定功能。所有的高级语言中都有子程序这个概念，用子程序来实现模块的功能。在C语言中，子程序的作用是函数来完成的。一个C程序可以有一个主函数和若干其他函数构成。主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或者多个函数调用任意次数。</p>
<p>在程序开发中，常将一些常用的功能模块编写成函数，放在公共函数库中供大家调用，以减少重复编写程序段的工作量。</p>

例 8.1 函数调用的例子

```c
# include <stdio.h>

void main()
{
  void printstar(); /* 声明 printstar 函数 */
  void print_message(); /* 声明 print_message 函数 */
  printstar(); /* 调用 printstar 函数 */
  print_message(); /* 调用 print_message 函数 */
  printstar(); /* 调用 printstar 函数 */
}

void printstar() /* 定义 printstar 函数 */
{
  printf("* * * * * * * * * * * *\n");
}


void print_message() /* 定义 print_message 函数 */
{
  printf(" How do you do! \n");
}
```

<p>printstar 和 print_message 都是用户定义的函数名。定义这两个函数时指定函数的类型为 void，意为函数无类型，即无函数值，执行这两个函数后不会把任何值带回 main 函数。</p>
<p>说明：</p>
<p>(1) 一个C程序由一个或多个程序模块组成，每一个程序模块作为一个源程序文件。对较大的程序，一般不希望把所有内容全放在一个文件中，而是将它们分别放在若干个源文件中，再由若干个源程序文件组成一个C程序。这样便于分别编写、分别编译，提高调式效率。一个源程序文件可以为多个C程序共用。</p>
<p>(2) 一个源程序文件有一个或多个函数以及其他有关内容(如命令行、数据定义等)组成。一个源程序文件是一个编译单位，在程序编译时是以源程序文件为单位进行编译，而不是以函数为单位。</p>
<p>(3) C程序的执行是从 main 函数开始，如在 main 函数中调用其他函数，在调用后流程返回到 main 函数，在 main 函数中结束整个程序的运行。</p>
<p>(4) 所有函数都是平行的，即在定义函数时是分别进行的，是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。函数间可以互相调用，但不能调用 main 函数。 main 函数是系统调用的。</p>
<p>(5) 从用户角度看函数有两种：</p>
<p>(5.1) 标准函数：即库函数，由系统提供，用户不必自己定义而直接使用。强调一下，不同C语言编译系统提供的库函数的数量和功能会有一些不同，当然许多基本的函数是共同的。。</p>
<p>(5.2) 用户自定义函数：用以解决用户专门需求的函数。</p>
<p>(6) 从函数的形式看：</p>
<p>(6.1) 无参函数：如例8.1中的 printstar 和 print_message。在调用无参函数时，主调函数不向被调用函数传递数据。</p>
<p>(6.2) 有参函数：主调函数在调用函数时，通过参数向被调用函数传递数据。</p>

## 8.2 函数定义的一般形式

### 8.2.1 无参函数定义的一般形式

```c
类型标识符 函数名()
{
  声明部分
  语句部分
}
```

<p>定义函数时要用"类型标识符"指定函数值的类型，即函数返回值的类型。</p>

### 8.2.2 有参函数定义的一版形式

```c
类型标识符 函数名(形式参数列表)
{
  声明部分
  语句部分
}
```

例如：

```c
int max(int x, int y) /* 默认函数类型为int， int可以省略 */
{
  int z; /* 函数体中的声明部分 */
  z = x > y ? x : y;
  return(z);
}
```

<p>如果在定义函数时不指定函数类型，系统会隐含指定函数类型为int型。因此上面定义的 max 函数左端的 int 可以省略。</p>

### 8.2.3 空函数

<p>在程序设计中会用到空函数，形式如下：</p>

```c
类型说明符 函数名()
{ }
```
如：

```c
void dummy()
{ }
```

<p>此函数被调用时不做任何工作。在主调函数中写上 "dummy();" 表明这里需要调用一个函数，而现在这个函数没有起作用，等以后扩充函数功能时补上。</p>
<p>在程序设计中往往要确定若干模块，分别由若干函数实现。而在第一阶段只设计最基本的模块，其他次要功能则在以后陆续补上。在初始阶段，在将来准备扩充功能的地方写上一个空函数(函数名去将来采用的实际函数名，如：merge 等)，先占一个位置，以后用编好的函数代替它。这样做，程序结构清晰，可读性强，方便以后扩充新功能，对程序结构影响不大，空函数在程序设计中很常见。</p>

## 8.3 函数参数和函数的值

### 8.3.1 形式参数和实际参数

<p>在调用函数时，大多数情况下，主调函数和被调用函数之间有数据传递关系。这就是前面提到的有参函数。在定义函数时函数名后面括号中农的把变量名称为"形式参数"，简称"形参"。在主调函数中调用一个函数时，函数名后面括号中的参数(可以是一个表达式)称为"实际参数"，简称"实参"。</p>

<p>例 8.2 函数调用时的数据传递。</p>

```c
# include<stdio.h>

void main()
{
	int max(int x, int y); /* 声明 max(int) 函数 */
	int a,b,c;
	scanf("%d, %d", &a, &b);
	c=max(a, b); /* 这里的 a,b 是实参 */
	printf("Max is %d", c);
}

int max(int x, int y) /* 定义 max(int) 函数， x，y是形参 */
{
	int z;
	z = x > y ? x : y;
	return (z);
}
```

<p>关于形参与实参的说明：</p>
<p>(1) 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。只有在发生函数调用时，函数 max 中的形参才被而分配内存单元。在调用结束后，形参所占内存单元也被释放。</p>
<p>(2) 实参可以是常量、变量或表达式，如：</p>

```c
max(3, a + b);
```

<p>但要求他们有确定的值。在调用函数时将实参的值赋给形参。</p>

<p>(3) 在被定义的函数中，必须指定形参的类型。</p>
<p>(4) 实参与形参的类型应相同或赋值兼容。如果实参为整型，而形参x为实数型，则按照第三章介绍的不同类型数值的赋值规则进行转换。在上面的例子中，应将max函数放在main函数前面，或者在main函数中对max函数进行原型声明，否则会报错。字符型与整型可以互相通用。</p>
<p>(5) C语言规定，实参变量对形参标量的数据传递是"值传递"，即单向传递。只由实参传给形参，而不能由形参传回来给实参。在内存中，实参单元与形参单元是不同的单元。</p>
<p>在调用函数时，给形参分配存储单元，并将实参对应的值传递给形参，调用结束后，形参单元被释放，实参单元保留并维持原值。在执行一个被调用函数时，形参的值如果发生改变，不会影响主调函数的实参的值。</p>

### 8.3.2 函数的返回值

<p>通常，希望通过函数调用使主调函数得到一个	确定的值，这就是函数的返回值。下面对函数值做一些说明：</p>
<p>(1) 函数的返回值是通过函数中的return语句获得的。return语句将被调用函数中的一个确定值带回主调函数中去。</p>
<p>如果需要从	被调用函数带回一个函数值(供主调函数使用)，被调用函数中必须包含return语句。如果不需要从被调用函数带回函数值可以不要return语句。</p>
<p>一个函数中可以有一个以上的return语句，执行到哪一个return语句，哪一个语句起作用。</p>
<p>return语句后面的括弧也可以不要，如：</p>

```c
return z;
```

<p>它与"return (z);"等价。</p>
<p>return后面的值可以是一个表达式。例如：例8.2中的函数max可以改写如下：</p>

```c
max(int x, int y)
{
	return (x > y ? x : y);
}
```

<p>这样函数体更为简短，一个return语句就把求值和返回都解决了。</p>

<p>(2) 函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。如：</p>

```c
int max(float x, float y); /* 函数值为整型 */
char letter(char c1, char c2); /* 函数值为字符型 */
double min(int x, int y); /* 函数值为双精度型 */
```

<p>例8.2中的函数定义并没有说明其类型，这是因为C语言规定，凡是不加类型说明的函数，一律自动按整型处理。例8.2中的max函数返回值为整型，因此可以不必说明。建议在定义时对所有函数都指定函数类型。</p>

<p>(3) 在定义函数时对指定的函数类型一般应该和return语句中的表达式类型一致。</p>

<p>如果函数值的类型和return语句中的表达式类型不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。</p>

<p>例 8.3 返回值类型与函数类型不同。将例8.2稍作改动(注意是变量的类型改动)。</p>

```c
# include<stdio.h>

void main()
{
	int max(float x, float y); /* 声明 max(int) 函数 */
	float a, b;
	int c;
	scanf("%f, %f", &a, &b);
	c=max(a, b); /* 这里的 a,b 是实参 */
	printf("Max is %d", c);
}

int max(float x, float y) /* 定义 max(float, float) 函数， x，y是形参 */
{
	float z; /* z是实型变量 */
	z = x > y ? x : y;
	return (z);
}
```

<p>函数max定义为整型，而return语句中的z为实型，二者不一致，按上述规定，现将z转换为整型，然后max(x, y)带回一个整型值2返回主调函数main。如果将main函数中c定义为实型，用%f格式符输出，也是 2.000000。</p>
<p>有时，可以利用这一特点进行类型转换。如：在函数中进行实型运算，希望返回的是整型，可以让系统自动完成类型转换。单这种做法往往使程序不清晰，降低可读性，易错，且并不是所有类型都能互相转换(如：实数与字符类型数据之间)。不建议初学者使用这种方式，而应做到使函数类型与return返回值的类型一致。</p>
<p>对于不带返回值的函数，应好用 "void" 定义函数为“无类型”(或者“空类型”)。这样系统就保证不使函数带回任何值，即禁止在调用函数中使用被调用函数的返回值。此时在函数体中不得出现return语句。</p>

## 8.4 函数的调用

### 8.4.1 函数调用的一般形式

```c
函数名(实参列表);
```

<p>调用无参函数，"实参列表"可以没有，但括号不能省略。实参列表的多个参数间用逗号隔开。实参应与形参个数相等，类型匹配。如实参列表包括多个实参，对实参的求值顺序是不确定的。</p>
<p>例 8.4 实参求值的顺序</p>

```c
#include <stdio.h>

void main()
{
    int f(int a, int b); /* 函数声明 */
    int i = 2, p;
    p = f(i, ++i); /* 函数调用 */
    printf("%d\n", p);
}

int f(int a, int b)
{
    int c;
    if(a > b)c = 1;
    else if(a == b)c = 0;
    else c = -1;
    return (c);
}
```

<p>如果按自左而右的顺序求实参的值，则函数调用相当于是f(2, 3)，则函数值为 -1。若按照自右而左顺序求值，则相当于是f(3, 3)，函数值为 0。</p>
<p>不同的编译系统实现不同，应当避免使用这种影响通用性的编程方式。可以在函数调用前先求出值。</p>

```c
j = i;
k = ++i;
p = f(j, k);
```

### 8.4.2 函数调用的方式

<p>按照函数在程序中出现的位置分，分以下三种函数调用方式：</p>


<p>1. 函数语句</p>
<p>把函数调用作为一个语句，如例 8.1 中的 "printstar();" ，这时不要求函数带回返回值，只要求函数完成一定的操作。</p>
<p>2. 函数表达式</p>
<p>函数出现在一个表达式中，这种表达式称为函数表达式。这时要求函数带回一个确定的值已参与表达式的运算。例如：</p>

```c
c = 2 * max(a, b);
```

<p>3. 函数参数</p>
<p>函数调用作为一个函数的参数。例如：</p>

```c
c = 2 * max(a, max(b, c));
```

<p>又如：</p>

```c
printf("%d", max(a, b));
```

<p>函数调用作为函数的参数，实质上也是函数表达式形式调用的一种，因为函数的参数本来就要求是表达式形式。</p>

### 8.4.3 对被调用函数的声明和函数原型

<p>在一个函数中调用另一个函数(即被调用函数)需要具备的条件如下。</p>
<p>(1)首先被调用的函数必须是已经存在的函数(是库函数或用户自己定义的函数)。</p>
<p>(2)如果使用库函数，还应该在本文件开头用 #include 命令将调用有关库函数时所需用到的信息"包含"到本文件中来。例如：前几章中已经用到过的命令：</p>

```c
#include<stdio.h>
```

<p>其中"stdio.h"是一个头文件。在stdio.h文件中包含了输入输出库函数所用到的一些宏定义信息，不包含就无法使用。同样，使用数据学库中的函数，就应该用：</p>

```c
#include<math.h>
```

<p>(3)如果使用用户自己定义的函数，而该函数的位置在调用他的函数(即主调函数)的后面(在同一个文件中)，应该在主调函数中对被调用的函数作声明。</p>
<p>"声明"一词的原文是 declaration ，过去在许多书中把它译为"说明"，现在越来越多的计算机专家提出应译为声明，更确切，表意更清楚。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。</p>
<p>例8.5 对被调用函数的声明。</p>

```c
#include <stdio.h>

void main()
{
    float add(float x, float y); /* 对被调用函数 add 的声明 */
    float a, b, c;
    scanf("%f, %f", &a, &b);
    c = add(a, b);
    printf("sum is %f\n", c);
}

float add(float x, float y) /* 函数首部 */
{
    float z; /* 函数体 */
    z = x + y;
    return (z);
}
```

<p>上面例子中的函数声明，可以不写形参名，只写形参的类型。如：</p>


```c
float add(float, float);
```

<p>编译系统只检查参数个数和参数类型，不检查参数名。</p>
<p>以上的函数声明称为函数原型(function prototype)。使用函数原型是 ANSI C 的一个重要特点。见例 8.5，main函数的位置在add函数的前面，而在进行编译时是从上到下逐行进行的，如果没有对函数的声明，当编译到调用 add 函数的那一行时，编译系统无法确定 add 是不是函数名，也饿无法判断实参(a，b)的类型和个数是否正确，因而无法进行正确性的检查。如果不做检查，在运行时才发现实参和形参的类型或个数不一致，出现运行错误。但是在运行阶段发现错误并重新调试程序，是比较麻烦的，工作量也较大。应当在编译阶段尽可能的多发现错误，并随之纠正。</p>
<p>现在，在函数调用之前用函数原型做了函数声明。因此编译系统记下了所需调用的函数的有关信息，在对"c = add(a, b);" 进行编译时就"有章可循"了。编译系统根据函数的原型对函数调用的合法性进行全面的检查。与函数原型不匹配的函数调用会导致编译出错，它属于语法错误。</p>
<p>注意：对函数的"定义"和"声明"不是一回事。函数的定义是指对函数功能的确立，不包括指定函数名、函数值类型、形参及其类型、函数体等，它是一个完整的、独立的函数单位。而函数的声明的作用则是把函数的名字、函数类型以及形参的个数、类型和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查。</p>
<p>函数声明的一般形式有两种：</p>
<p>(1) 函数类型 函数名(参数类型1, 参数类型2, ..., 参数类型N);</p>
<p>(2) 函数类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ..., 参数类型N 参数名N);</p>
<p>第一种是基本形式。为了便于阅读，也允许在函数原型中加上参数名，就形成了第二种形式。但是编译系统不检查参数名，因此参数名是什么都无所谓。</p>
<p>需要保证函数声明和函数定义的首部写法上的一致，即函数类型、函数名、参数个数、参数了诶性和参数顺序必须相同。函数调用时的函数名、实参个数、实参顺序与函数原型一致。实参类型必须与函数原型中的形参类型赋值兼容(按照第三章介绍的赋值规则进行类型转换)。否则就按照出错处理。</p>
<p>用函数原型来声明函数，能减少编写程序时可能出现的错误。由于函数声明的位置与函数调用语句的位置比较接近，在写程序时便于就近参照函数原型来书写函数调用，不易出错。</p>
<p>说明：</p>
<p>(1)以前C语言版本的函数声明不是采用函数原型，而只声明函数名和函数类型。例如在例 8.5 中采用下面的函数声明方式：</p>

```c
float add();
```

<p>不包括参数类型和参数个数。系统不检查参数类型和个数。新版本也兼容这种用法，但是不提倡这种用法，因为它未对函数调用的合法性进行全面的检查。</p>

<p>(2)如果被调用的函数的定义在主调函数之前，可以不必加以声明。因为编译系统已经先知道了已定义函数的有关情况，会根据函数首部提供的信息对函数的调用作正确性检查。例 8.5 可以改造如下：</p>


```c
#include <stdio.h>

float add(float x, float y) /* 函数首部 */
{
    float z; /* 函数体 */
    z = x + y;
    return (z);
}

void main() /* 不必对被调用函数 add 作声明 */
{
    float a, b, c;
    scanf("%f, %f", &a, &b);
    c = add(a, b);
    printf("sum is %f\n", c);
}
```

<p>(3)如果已在文件的开头(在所有函数之前)，已对本文件中所调用的函数进行了声明，则在各函数中不必对其所调用的函数再做声明。例如：</p>

```c
char letter(char, char); /* 以下三行在所有函数之前，且在函数外部 */
float f(float, float);
int i(float, float);

void main() /* 在 main 函数中要调用 letter、f、i，不必对它所调用的三个函数进行声明 */
{
...
}

/* 下面定义被 main 函数调用的3个函数 */
char letter(char c1, char c2) /* 定义 letter 函数 */
{
...
}

float f(float x, float y) /* 定义 f 函数 */
{
...
}

int i(float j, float k) /* 定义 i 函数 */
{
...
}
```

<p>(4)如果被调用的函数类型为整型，C语言允许在调用函数前不必作函数原型声明。如例 8.4 可以写成如下形式：</p>

```c
#include <stdio.h>

void main()
{ /* 可以没有函数声明 */
    int i = 2, p;
    p = f(i, ++i); /* 函数调用 */
    printf("%d\n", p);
}

f(int a, int b) /* 定义整型函数，省写了类型标识符 int */
{
    int c;
    if(a > b)c = 1;
    else if(a == b)c = 0;
    else c = -1;
    return (c);
}
```

<p>但是使用这种方法，系统无法对函数参数的个数和类型进行检查。若调用函数时参数使用不当，在编译时也不会报错，而在运行时出错。而且，Turbo C和Visual C++要求对所有被调用的函数进行声明。为了程序清晰和安全及通用性，编写程序时最好都加上函数原型声明。</p>

## 8.5 函数的嵌套调用

<p>C语言的函数定义是互相平行、独立的，定义函数时，一个函数内不能包含另一个函数。</p>
<p>C语言不能嵌套定义函数，但可以嵌套调用函数。</p>

## 8.6 函数的递归调用

<p>在调用一个函数的过程中又出现直接或间接地调用该函数本身，成为二函数的递归调用。C语言的特点之一就是允许函数的递归调用。</p>

## 8.7 数组作为函数参数

<p>可以用变量做函数参数，同样也可以用数组元素作函数参数，用法与变量相同。数组名也可以作实参和形参，传递的是数组首元素的地址。</p>

### 8.7.1 数组元素作函数实参

<p>实参可以是表达式，而数组元素可以是表达式的组成部分，因此数组元素当然可以作为函数的实参，与用变量作实参一样，是单向传递，即"值传递"的方式。</p>
<p>例 8.10 有两个数组a和b，各有10个元素，分别统计两个数组响应元素大于、等于、小于的次数。</p>

```c
#include<stdio.h>

void main()
{
    int large(int x, int y);
    int a[10], b[10], i, r, n = 0, m = 0, k = 0;
    printf("enter array a : \n");
    for(i = 0; i < 10; i++)
        scanf("%d", &a[i]);
    printf("\n");
    printf("enter array b : \n");
    for(i = 0; i < 10; i++)
        scanf("%d", &b[i]);
    printf("\n");
    for(i = 0; i < 10; i++)
    {
        r = large(a[i], b[i]);
        if(r == 1)
            n = n + 1;
        else
            if(r == 0)
                m = m + 1;
            else
                k = k + 1;
    }
    printf("a[i] > b[i] %d times\n", n);
    printf("a[i] = b[i] %d times\n", m);
    printf("a[i] < b[i] %d times\n", k);
    if(n > k)
        printf("array a is larger to array b\n");
    else if(n < k)
        printf("array a is smaller to array b\n");
    else
        printf("array a is equal to array b\n");
}

int large(int x, int y)
{
    int flag;
    if(x > y)
        flag = 1;
    else if(x < y)
        flag = -1;
    else
        flag = 0;
    return (flag);
}
```

### 8.7.2 数组名为函数参数

<p>可以用数组名作函数参数，此时形参应当用数组名或指针变量。</p>
<p>例 8-11 有一个一维数组score，内放10个学生成绩，求平均值。</p>


```c
#include <stdio.h>

void main()
{
    float average(float array[10]);
    float score[10], aver;
    int i;
    printf("input 10 scores : \n");
    for(i = 0; i < 10; i++)
        scanf("%f", &score[i]);
    printf("\n");
    aver = average(score);
    printf("average score is %5.2f\n", aver);
}

float average(float array[10])
{
    int i;
    float aver, sum = array[0];
    for(i = 0; i < 10; i++)
        sum = sum + array[i];
    aver = sum / 10;
    return (aver);
}
```

<p>关于数组名作为函数参数的说明：</p>
<p>(1) 用数组名作为函数参数，应该在主调用函数和被调用函数分别定义数组，上例中array是形参数组名，score是实参数组名，分别在其所在函数中定义，不能只在一方定义。</p>
<p>(2) 实参数组与形参数组类型应一致，否则结果会出错。</p>
<p>(3) 在被调用函数中声明了形参数组的大小为10，实际上指定大小是不起任何作用的，因为C语言编译对形参数组大小不做检查，只是将实参数组的首元素地址传给形参数组。因此，形参数组名获得了实参数组的首元素地址。</p>
<p>(4) 形参数组可以不指定大小，在定义数组时在数组名后面跟一个空的方括号。有时为了在被调用函数中处理数组元素的需要，可以另设一个形参，传递需要处理的数组元素的个数。</p>

<p>例 8.12 形参数组不定义长度</p>

```c
#include <stdio.h>

void main()
{
    float average(float array[], int n);
    float score_1[5] = {98.5, 97, 91.5, 60, 55};
    float score_2[10] = {67.5, 89.5, 99, 69.5, 77, 89.5, 76.5, 54, 60, 99.5};
    int i;
    printf("the average of class A is %6.2f\n", average(score_1, 5));
    printf("the average of class B is %6.2f\n", average(score_2, 10));
}

float average(float array[], int n)
{
    int i;
    float aver, sum = array[0];
    for(i = 0; i < n; i++)
        sum = sum + array[i];
    aver = sum / n;
    return (aver);
}
```

<p>(5) 用数组名做函数实参时，不是把数组元素的值传递给形参，而是把实参数组的首元素的地址传递给形参数组，这样两个数组就共占同一段内存单元。也就是说，形参数组中各元素的值如果发生变化，会使实参数组元素的值同时发生变化。这一点是与变量作函数参数的情况不同。</p>

### 8.7.3 多维数组名作函数参数

<p>可以用多维数组名作为函数的实参和形参，在被调用函数中对形参数组定义时可以指定每一维的大小，也可以省略第一维的大小说明。例如：</p>

```c
int array[3][10];
```

或

```c
int array[][10];
```

<p>二者都是合法且等价的。但是不能把第二维以及其他高维的大小说明省略。如下面的定义是不合法的：</p>

```c
int array[][];
```

<p>之前已说明，二维数组是由若干个一维数组组成的，在内存中，数组是按行存放的，因此在定义二维数组时，必须指定列数(即一行中包含几个元素)，由于形参数组与实参数组类型相同，所以它们是由具有相同长度的一维数组所组成的。不能只指定第一维(行数)而忽略第二维(列数)，下面的写法是错误的：</p>

```c
int array[3][];
```

<p>在第二维大小相同的前提下，形参数组的第一维可以与实参数组不同。</p>
<p>这时形参数组和实参数组都是由相同类型和大小的一维数组组成。C语言编译系统不检查第一维的大小。</p>
<p>例 8.14 求一个3X4矩阵中所有元素的最大值</p>

```c
#include <stdio.h>

void main()
{
    int max_value(int array[][4]);
    int a[3][4] = {{1,3,5,7},{2,4,6,8},{15,17,34,12}};
    printf("max value is %d\n", max_value(a));
}

int max_value(int array[][4])
{
    int i, j, max;
    max = array[0][0];
    for(i = 0; i < 3; i++)
        for(j = 0; j < 4; j++)
            if(array[i][j] > max)
                max = array[i][j];
    return (max);
}
```

## 8.8 局部变量和全局变量

### 8.8.1 局部变量

<p>在一个函数内部定义的变量是【局部变量】，它只在本函数内部有效，在本函数以外不能使用它们。</p>
<p>说明：</p>
<p>(1) 主函数中的局部变量与普通函数中的局部变量作用域一致。主函数中定义的变量也只能在主函数中有效，主函数也不能使用其他函数中定义的变量。</p>
<p>(2) 不同函数的局部变量可以命名相同。它们代表不同的对象，在内存中占用不同的内存单元，互不混淆。</p>
<p>(3) 形式参数也是局部变量。</p>
<p>(4) 在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序”或“程序块”。</p>

```c
void main()
{ /* a, b在此范围内有效 */
    int a, b;
    ...
    { /* c在此范围内有效 */
        int c;
        c = a + b;
        ...
    }
    ...
}
```

<p>(5) 上例中变量c只在复合语句(分程序)内有效，离开复合语句该变量就无效，释放内存单元。</p>

### 8.8.2 全局变量(外部变量/全程变量)

<p>前面提过，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，在函数外定义的变量是外部变量，也叫全局变量、全程变量。全局变量可以为本文件中其它函数所共用。它的有效范围是从定义变量的位置开始到本源文件结束。</p>
<p>说明：</p>
<p>(1) 设置全局变量的作用是增加了函数间数据联系的渠道。由于同一文件中所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其它函数，相当于是各个函数间有直接的传递通道。由于函数的调用只能带回一个返回值，因此有时可以利用全局变量增加函数间的联系渠道，通过一次函数调用能得到一个以上的值。</p>
<p>为了便于区别全局变量和局部变量，在C程序设计人员中有一个不成文的约定(但非规定)，将全局变量名的第一个字母用大写表示。</p>

<p>例 8.15 有一个一维数组，内放10个学生成绩，写一个函数，求平均分、最高分和最低分。</p>
<p>显然希望通过函数调用得到3个结果值，除了可以从函数得到一个函数返回值外，还可以利用全局变量。</p>

```c
#include <stdio.h>

float Max = 0, Min = 0; /* 全局变量 */

void main()
{
    float average(float array[], int n);
    float ave, score[10];
    int i;
    for(i = 0; i < 10; i++)
        scanf("%f", &score[i]);
    ave = average(score, 10);
    printf("max = %6.2f\nmin = %6.2f\naverage = %6.2f\n", Max, Min, ave);
}

float average(float array[], int n) /* 定义函数，形参为数组 */
{
    int i;
    float aver, sum = array[0];
    Max = Min = array[0];
    for(i = 1; i < n; i++)
    {
        if(array[i] > Max) Max = array[i];
        if(array[i] < Min) Min = array[i];
        sum = sum + array[i];
    }
    aver = sum / n;
    return (aver);
}
```

<p>可以利用全局变量减少函数实参与形参的个数，从而减少内存空间以及传递数据时的时间消耗。</p>

<p>(2) 不建议在非必要时使用全局变量，原因如下。</p>
<p>(2.1) 全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟内存单元。</p>
<p>(2.2) 降低函数的通用性。函数在执行时依赖外部变量。移植函数时需要把有关的外部变量和值一起移植过去。如果在目标移植文件中遇到同名变量，就会出现问题，降低了程序的可靠性和通用性。在程序设计中要求模块“内聚性”强，与其它模块的“耦合性”弱。即要求模块功能单一，与其他模块的相互影响要尽量少，而全局变量是不符合这个原则的。一般要求把C程序中的函数做成一个封闭体，除了通过“形参-实参”的渠道与外界发生联系外，没有其它渠道。这样的程序移植性好，可读性强。</p>
<p>(2.3) 使用全局变量过多，会降低程序的清晰性，难以清楚的判断出每个瞬时各个外部变量的值。各个函数在执行时都可能改变外部变量的值，程序易出错。因此，要限制使用全局变量。</p>
<p>(3) 如果在同一个源文件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量被“屏蔽”，不起作用。</p>
<p>例 8.16 外部变量与局部变量同名</p>

```c
#include <stdio.h>

int a = 3, b = 5; /* a、b为外部变量 */

void main()
{
    int max(int a, int b); /* 本行为函数声明，a、b为形参名 */
    int a = 8; /* a为局部变量 */
    printf("%d\n", max(a, b));
}

int max(int a, int b) /* a、b为形参局部变量，作用域整个max函数 */
{
    int c;
    c = a > b ? a : b;
    return (c);
}
```

<p>故意重复使用a、b为变量名，注意区别不同a、b的含义和作用域。</p>
<p>形参也是局部变量，外部变量a、b在在max函数范围内不起作用。</p>

## 8.9 变量的存储类

### 8.9.1 动态存储方式和静态存储方式

<p>从变量的作用域(即从空间)角度来分，可以分为全局变量和局部变量。</p>
<p>从变量值的存在时间(即生存周期)角度来分，可以分为【静态存储方式】和【动态存储方式】。</p>
<p>所谓静态存储方式，是指在程序运行期间由系统分配固定的存储空间的方式。而动态存储方式则是在程序运行期间根据需要进行动态的分配存储空间的方式。</p>
<p>内存中供用户使用的存储空间，可以分为三部分，见图8-16</p>

<p>图 8-16</p>
<table>
<tr>
<td rowspan=3>用户区</td>
<td>程序区</td>
</tr>
<tr>
<td>静态存储区</td>
</tr>
<tr>
<td>动态存储区</td>
</tr>
<table>

<p>数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。</p>
<p>在动态存储区中存放以下数据：</p>
<p>① 函数形式参数。在调用函数时给形参分配存储空间。</p>
<p>② 自动变量(未加static声明的局部变量)</p>
<p>③ 函数调用时的现场保护和返回地址等。</p>
<p>函数调用开始时分配动态存储空间，结束时释放这些空间。在程序执行过程中，这种分配是动态的，如果在一个程序中两次调用同一个函数，分配给此函数中的局部变量的存储空间地址可能是不同的。如果一个程序包含若干个函数，每个函数中的局部变量的生存周期并不等于整个程序的执行周期，它只是程序执行周期的一部分。根据函数调用的需要，动态的分配和释放存储空间。</p>
<p>在C语言中，每一个变量和函数有两个属性：数据类型和数据的存储类别。数据类型第三章讲过。存储类别是指数据在内存中的存储方式。分为两大类：静态存储和动态存储。具体包含四种：自动的 auto、静态的 static、寄存器的 register、外部的 extern。根据变量的存储类别，可以知道变量的作用域和生存周期。</p>

### 8.9.2 auto变量

<p>函数中的局部变量，如果不专门声明为 static，就都是动态分配存储空间的，数据存储在动态存储区中农。函数中的形参和在函数中定义的变量(包括在复合语句中定义的变量)，都属于此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时自动释放这些存储空间。因此这类局部变量称为自动变量。自动变量用关键字 auto 作为存储类别的声明。例如：</p>

```c
int f(int a) /* 定义 f 函数，a为形参 */
{
    auto int b, c = 3; /* 定义b、c为自动变量 */
    ...
}
```

<p>其中，a是形参，b、c是自动变量，对c赋初值3。执行完f函数后，自动释放a、b、c所占用的存储单元。</p>
<p>实际上关键字“auto”可以省略，auto不写则隐含确定为“自动存储类别”，它属于动态存储方式。程序中大多数变量都属于自动变量。前面介绍的函数中定义的变量都没有声明为auto，其实都隐含指定为自动变量。下面两种方式等价：</p>

```c
auto int b, c = 3;
```

```c
int b, c = 3;
```

### 8.9.3 用static声明局部变量

<p>有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，改变量已有值，并且是上次函数调用结束时的值。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。</p>
<p>例 8.17</p>

```c
#include <stdio.h>

void main()
{
    int f(int);
    int a = 2, i;
    for(i = 0; i < 3; i++)
        printf("%d", f(a));
}

int f(int a)
{
    auto int b = 0;
    static int c = 3; /* f函数调用结束时此变量所占用的内存单元不释放并保留当前值 */
    b = b + 1;
    c = c + 1;
    return (a + b + c);
}
```

<p>静态局部变量的说明：</p>
<p>(1) 静态局部变量属于静态存储类别，在静态存储区分配存储单元。在程序整个运行期间都不释放。而自动变量(动态局部变量)属于动态存储类别，占动态存储区空间而不占静态存储区空间，函数调用结束后即释放。</p>
<p>(2) 对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。</p>
<p>(3) 如在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0(对数值型变量)或空字符(对字符型变量)。而对自动变量来说，如果不赋初值，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的存储单元中的值是不确定的。</p>
<p>(4) 虽然静态局部变量在函数调用结束后仍然存在，但其它函数是不能引用它的。</p>
<p>需要用静态局部变量的情况如下：</p>
<p>(1) 需要保留函数上一次调用结束时的值。如：求 n!。</p>
<p>例 8.18 输出1到5的阶乘值。</p>

```c
#include <stdio.h>

void main()
{
    int fac(int n);
    int i;
    for(i = 1; i <= 5; i++)
        printf("%d != %d\n", i, fac(i));
}

int fac(int n)
{
    static int f = 1; /* 编译时初始化，变量只被引用而不改变值 */
    f = f * n;
    return (f);
}
```
<p>(2) 如果初始化后，变量只被引用而不改变其值，则这时用静态静态局部变量比较方便，以免每次调用时重新赋值。</p>
<p>但是，用静态存储要多占内存(长期占用不释放，而不能像动态存储那样一个存储单元可供多个变量使用，节约内存)，并且降低了程序的可读性，当调用次数多时往往弄不清静态局部变量的当前值是什么。因此，非必要不使用静态局部变量。</p>

### 8.9.4 register变量

<p>一般情况下，变量(包括静态存储方式和动态存储方式)的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。</p>
<p>如果有一些变量使用频繁，则为存取变量的值要花费不少时间。为提高执行效率，C语言允许将局部变量的值放在CPU中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量叫做寄存器变量，用关键字register作声明。</p>

<p>例 8.19 使用寄存器变量。</p>

```c
#include <stdio.h>

void main()
{
    long fac(long);
    long i, n;
    scanf("%ld", &n);
    for(i = 1; i <= n; i++)
        printf("%ld != %ld\n", i, fac(i));
}

long fac(long n)
{
    register long i, f = 1; /* 定义寄存器变量，如果n的值大，能节约许多执行时间 */
    for(i = 1; i <= n; i++)
        f = f * i;
    return (f);
}
```

<p>说明：</p>
<p>(1) 只有局部自动变量和形式参数可以作为寄存器变量，其它(如全局变量)不行。在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束释放寄存器。此后调用另一个函数时又可以利用它来存放该函数的寄存器变量。</p>
<p>(2) 一个计算机系统中的寄存器数目是有限的，不能定义任意多个寄存器变量。不同的系统允许使用的寄存器个数是不同的，而且对register变量的处理方法也是不同的，有的系统对register变量当做自动变量处理，分配内存单元，并不真正把它们存放在寄存器中，有的系统只允许将int、char和指针型变量定义为寄存器变量。</p>
<p>(3) 局部静态变量不能定义为寄存器变量。不能写成</p>

```C
register static int a, b, c;
```

<p>不能把变量即放在静态存储区又放在寄存器中，二者只能居其一。对一个变量只能声明为一种存储类别。</p>
<p>当今的优化编系统能够识别使用频繁的变量，从而自动的将这些变量放在寄存器中，而不需要程序设计者指定。因此，用register声明变量是不必要的。编程人员只需要对它有一定了解即可。</p>

### 8.9.5 用extern声明外部变量

<p>外部变量是在函数的外部定义的全局变量，他的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为程序中各个函数所引用。编译时将外部变量分配在静态存储区。</p>
<p>有时需要用extern来声明外部变量，以扩展外部变量的作用域。</p>
<p><b>1，在一个文件内声明外部变量</b></p>
<p>如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字extern对改变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
<p>例 8.20</p>

```c
#include <stdio.h>

void main()
{
    int max(int, int);
    extern int A, B;// 没有类型（不推荐） 这是 合法的旧式 C 写法（早期 C 允许变量声明时不写类型，默认是 int），但在现代 C 标准（C99 及之后）中，这是不被推荐的写法，有些编译器在默认严格模式下会报错。
    printf("%d\n", max(A, B));
}

int A = 13, B = -8;

int max(int x, int y)
{
    int z;
    z = z > y ? x : y;
    return (z);
}
```

<p>外部变量A、B定义在main函数之后，因此在main函数中不能引用外部变量A和B。在main函数中用extern对A和B进行“外部变量声明”，表示A和B是已经定义的外部变量(但定义位置在后面)。这样在main函数中就可以合法地使用全局变量A和B了。如果不作extern声明，编译时出错，系统不能识别A、B是已定义的外部变量。一般做法是外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。</p>
<p>用extern声明外部变量时，类型名也可以省略。以下两种方式等价：</p>

```c
extern int A, B;
```
```c
extern A, B;
```
<p><b>2，在多程序的文件中声明外部变量</b></p>
<p>一个C程序可以由一个或多个源程序文件组成。如果程序只是由一个源文件组成，使用外部变量的方法前面已经介绍。</p>
<p>如果程序由两个源程序文件组成，在两个文件中都要用到同一个外部变量Num，不能分别在两个文件中各自定义一个外部变量Num，否则在进行程序的连接时会出现“重复定义”的错误。正确的做法是：在任意一个文件中定义外部变量Num，而在另一个文件中用extern对Num作“外部变量声明”。即“extern Num;”。在编译和连接时，系统会由此知道Num是一个已在别处定义的外部变量，并将在另一个文件中定义的外部变量的作用域扩展到本文件，在本文件中可以合法地引用外部变量Num。</p>
<p>例 8.21 用extern将外部变量的作用域扩展到其它文件</p>
<p><b>文件file1.c中的内容为：</b></p>

```c
#include <stdio.h>

int A;

void main()
{
    int power(int);
    int b = 3, c, d, m;
    printf("enter the number a and its power m : \n");
    scanf("%d,%d", &A, &m);
    c = A * b;
    printf("%d * %d = %d\n", A, b, c);
    d = power(m);
    printf("%d * %d = %d\n", A, m, d);
}
```

<p><b>文件file2.c中的内容为：</b></p>

```c
extern A; /* 声明A为一个已经定义的外部变量，不必在为它分配内存 */

int power(int n)
{
    int i, y = 1;
    for(i = 1; i <= n; i++)
        y *= A;
    return (y);
}
```

<p>在编译时遇到extern时，先在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；如果找不到，就在连接时从其它文件中找外部变量的定义。如果从其它文件中找到了，就将作用域扩展到本文件；如果再找不到，就按出错处理。</p>

### 8.9.6 用static声明外部变量

<p>有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其它文件引用。这时可以在定义外部变量时加一个static声明。</p>
<p>这种加上static声明、只能用于本文件的外部变量，称为“静态外部变量”。在程序设计中，经常是多人协作完成各个模块，各人可独立的在其设计的文件中使用相同的外部变量名而不互相干扰，只要在本文件中不想被其它文件引用的外部变量前面加上static。</p>
<p>注意：不要以为对外部变量加上static以后才是静态存储方式，不加static就是动态存储方式。两种形式的外部变量都是静态存储方式，只是作用范围不同而已，都是在编译时分配内存。</p>

### 8.9.7 关于变量的声明和定义

<p>第三章介绍了如何定义一个变量。本章介绍了如何对一个变量的存储类别作声明。定义和声明是两回事。</p>
<p>第三章介绍了函数一般由两部分组成：声明部分和执行语句。声明部分的作用是对有关的标识符(如变量、函数、结构体、共用体)的属性进行说明。对于函数，声明和定义的区别是明显的。函数的声明是函数的原型，而函数的定义是函数的本身。对被调用函数的声明是放在主调函数的声明部分中的，而函数的定义显然不在声明部分的范围内，它是一个独立的模块。</p>
<p>对变量而言，声明与定义的关系稍微复杂一些。在声明部分出现的变量有两种情况：一种是需要建立存储空间的(如：int a;)，另一种是不需要建立存储空间的(如：extern a;)。前者称为“定义性声明”(defining declaration)，或者简称定义(definition)。后者称为“引导性声明”(referencing declaration)。广义的说，声明包括定义，但并非所有的声明都是定义。对“int a;”而言，它既是声明，又是定义。而对“extern a;”而言，它是声明而不是定义。一般为了叙述方便，把建立存储空间的声明称定义，把不需要建立存储空间的声明称为声明。显然这里指的声明是狭义的，即非定义性声明。例如：</p>

```c
void main()
{
    extern A; /* 是声明，不是定义，声明A是一个已定义的外部变量 */
    ...
}

int A; /* 是定义，定义A为整型外部变量 */
```

<p>外部变量的声明和外部变量的含义是不同的。外部变量的定义只能有一次，它的位置在所有函数之外，而同一文件中的外部变量的声明可以有多次，它的位置可以在函数之内(哪个函数要用就在哪个函数中声明)，也可以在函数之外(在外部变量的定义点之前。系统根据外部变量的定义(而不是根据外部变量的声明)分配存储单元。对外部变量的初始化只能在“定义”时进行，而不能再“声明”中进行。所谓“声明”，其作用是声明该变量是一个已在后面(或在其它文件中)已定义的外部变量，仅仅是为了扩展该变量的作用范围而作的“声明”。extern 只用作声明，而不用于定义。</p>
<p>用 static 来声明一个变量的作用有二：</p>
<p>(1) 对局部变量用static声明，则使该变量在整个程序执行期间不释放，为其分配的空间始终在。</p>
<p>(2) 全局变量用static声明，则该变量的作用域只限于本文件模块(即被声明的文件中)。</p>
<p>注意：用auto、register、static声明变量时，是在定义变量的基础上加上这些关键字，不能单独使用。</p>

```c
int a; /* 先定义整型变量a */
static a; /* 再对变量a声明为静态变量，这样在编译时会被认定为“重新定义”，这种用法是不对的 */
```

### 8.9.8 存储类别小结

<p>综上可知，对一个数据的定义，需要指定两种属性：数据类型和存储类别，分别使用三个关键字</p>

```c
static int a; /* 静态内部整型变量或静态外部整型变量 */
auto char c; /* 自动变量，在函数内部定义 */
register int d; /* 寄存器变量，在函数内定义 */
```

<p>此外，可以用extern声明变量为已定义的外部变量，如：</p>

```c
extern b; /* 声明b是一个已经被定义的外部变量 */
```

<p>下面从不同角度做些归纳：</p>
<p>(1) 从作用域角度分，有局部变量和全局变量。</p>

<table>
<tr>
<td rowspan=6>按作用域角度分</td>
<td rowspan=4>局部变量</td>
<td>自动变量，即动态局部变量(离开函数，值就消失)</td>
</tr>
<tr>
<td>静态局部变量(离开函数，值仍保留)</td>
</tr>
<tr>
<td>寄存器变量(离开函数，值就消失)</td>
</tr>
<tr>
<td>(形式参数可以定义为自动变量或寄存器变量)</td>
</tr>
<tr>
<td rowspan=2>全局变量</td>
<td>静态外部变量(只限本文件引用)</td>
</tr>
<tr>
<td>外部变量(即非静态的外部变量，允许其它文件引用)</td>
</tr>
</table>

<p>(2) 从变量存在时间(生存期)来区分，有动态存储和静态存储两类。静态存储是程序整个运行时间都存在，而动态存储是在调用函数时临时分配单元。</p>

<table>
<tr>
<td rowspan=6>按变量存在时间分</td>
<td rowspan=3>动态存储</td>
<td>自动变量(本函数内有效)</td>
</tr>
<tr>
<td>寄存器变量(本函数内有效)</td>
</tr>
<tr>
<td>形式参数(本函数内有效)</td>
</tr>
<tr>
<td rowspan=3>静态存储</td>
<td>静态局部变量(函数内有效)</td>
</tr>
<tr>
<td>静态外部变量(本文件内有效)</td>
</tr>
<tr>
<td>外部变量(其它文件可引用)</td>
</tr>
</table>

<p>(3) 从变量值存放的位置来分：</p>

<table>
<tr>
<td rowspan=6>按变量值存放的位置分</td>
<td rowspan=3>内存中静态存储区</td>
<td>静态局部变量</td>
</tr>
<tr>
<td>静态外部变量(函数外部静态变量)</td>
</tr>
<tr>
<td>外部变量(可为其它文件引用)</td>
</tr>
<tr>
<td rowspan=2>内存中动态存储区</td>
<td>自动变量</td>
</tr>
<tr>
<td>形式参数</td>
</tr>
<tr>
<td>CPU中的寄存器</td>
<td>寄存器变量</td>
</tr>
</table>

<p>(4) 关于作用域和生存期的概念。对一个变量的性质可以从两个方面分析，一是变量的作用域，一是变量值存在时间的长短，即生存期。前者是从空间的角度，后者是从时间的角度。二者有联系但不是同一回事。</p>
<p>如果一个变量在某个文件或函数范围内是有效的，则称该文件或函数为该变量的作用域，在此作用域内可以引用该变量，所以又称变量在此作用域内“可见”，这种性质称为变量的可见性。如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的“生存期”，或称该变量在此时刻“存在”。</p>

<p>表 8-2 各种类型变量的作用域和存在性</p>

<table>
<tr>
<td rowspan=2>变量存储类别</td>
<td colspan=2>函数内</td>
<td colspan=2>函数外</td>
</tr>
<tr>
<td>作用域</td>
<td>存在性</td>
<td>作用域</td>
<td>存在性</td>
</tr>
<tr>
<td>自动变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>寄存器变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>静态外部变量</td>
<td>O</td>
<td>O</td>
<td>O(只限本文件)</td>
<td>O</td>
</tr>
<tr>
<td>外部变量</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
</table>

<p>(5) static对局部变量和全局变量的作用不同。对局部变量来说，它使变量由动态存储方式变为静态存储方式。对全局变量来说，它使变量局部化(局部于本文件)，但仍为静态存储方式。从作用域角度看，凡有static声明的，其作用域都是局限的，或者是局限于本函数内(静态局部变量)，或者局限于本文件内(静态外部变量)。</p>

## 8.10 内部函数和外部函数

<p>函数本质上是全局的，因为一个函数要被另外的函数调用，但是也可以指定函数不能被其它文件调用。根据函数是否能被其它函数调用，将函数区分为内部函数和外部函数。</p>

### 8.10.1 内部函数

<p>如果一个函数只能被本文件中其它函数锁调用，就是内部函数。在定义内部函数时，在函数名和函数类型的前面加static，即：</p>

```c
static 类型标识符 函数名(形参表);
```

<p>例如：</p>

```c
static int fun(int a, int b);
```

<p>内部函数又叫静态函数，因为它是用static声明的。这样可以使函数的作用域只局限于所在文件，在不同文件中有同名的内部函数，互不干扰。这样可以让开发者不必担心所用函数是否会与其他文件中的函数同名，通常把只能由同一文件使用的函数和外部变量放在一个文件中，在它们前面都冠以static使之局部化，其它文件不能使用。</p>

### 8.10.2 外部函数

<p>(1) 在定义函数时，如果在函数的首部的最左端加关键字extern，表示此函数是外部函数，可供其它文件调用。</p>
<p>如函数首部可以写成：</p>

```c
extern int fun(int a, int b);
```

<p>这样，函数fun就可以为其它文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。本书前面锁用的函数都是外部函数。</p>
<p>(2) 在需要调用此函数的文件中，用extern对函数作声明，表示该函数是在其它文件中定义的外部函数。</p>
<p>例 8.22 有一个字符串，内有若干个字符，今输入一个字符，要求程序将字符串中该字符删去。用外部函数实现。</p>
<p><b>file1.c(文件1)</b></p>

```c
#include <stdio.h>

void main()
{
    extern void enter_string(char str[]); /* 可以写成 enter_string(char str[]); */
    extern void delete_string(char str[], char ch);
    extern void print_string(char str[]);
    /* 以上3行声明在本函数中将要调用的在其它文件中定义的三个函数 */
    
    char c;
    char str[80];
    enter_string(str);
    scanf("%c", &c);
    delete_string(str, c);
    print_string(str);
}
```

<p><b>file2.c(文件2)</b></p>

```c
#include <stdio.h>

void enter_string(char str[]) /* 定义外部函数 enter_string */
{
    gets(str); /* 向字符数组输入字符串 */
}
```

<p><b>file3.c(文件3)</b></p>

```c
#include <stdio.h>

void delete_string(char str[], char ch) /* 定义外部函数 delete_string */
{
    int i, j;
    for(i = j = 0; str[i] != '\0'; i++)
        if(str[i] != ch)
            str[j++] = str[i];
    
    str[j] = '\0';
}
```

<p><b>file4.c(文件4)</b></p>

```c
#include <stdio.h>

void print_string(char str[]) /* 定义外部函数 print_string */
{
    printf("%s\n", str);
}
```

<p>上例可知：使用extern声明就能够在一个文件中调用其它文件中定义的函数，或者说把该函数的作用域扩展到本文件。extern声明的形式就是在函数原型基础上加上关键字 extern(见本例main函数中的声明形式)。由于函数在本质上是外部的，在程序中经常要调用外部函数，为方便编程，C语言允许在声明函数时省写extern。例 8.21程序中main函数中对power函数的声明就没有用extern，但作用相同。一般都省写extern，例如例 8.22程序中main函数中的第一个函数声明。</p>
<p>这就是多次用过的函数原型。</p>
<p>由此可以进一步理解函数原型的作用。用函数原型能够把函数的作用域扩展到定义该函数的文件之外(不必使用extern)。只要在使用该函数的每一个文件中包含该函数的函数原型即可。函数原型通知编译系统：该函数在本文件中稍后定义，或在另一文件中定义。</p>
<p>利用函数原型扩展函数作用域最常见的例子是 #include 命令的应用，引入头文件。要求程序设计者在调用库函数时先从手册中查出所用的库函数的原型，并在程序中一一写出来是十分麻烦而困难的。为了减少程序设计者的困难，使用include命令引入相关库的头文件，里面包含了该库的所有函数原型和其它有关信息，就能在该文件中合法的调用该库的各个函数了。</p>
