# 目录

# 第一章 C语言概述

# 第二章 程序的灵魂 --- 算法

# 第三章 数据类型、运算符与表达式

## 3.1 C语言的数据类型

* 数据结构：数据的组织形式

### C语言提供的数据类型

<table>
<tr>
<td rowspan=10>数据类型</td>
<td rowspan=5>基本类型</td>
<td colspan=2>整数型</td>
</tr>
<tr>
<td rowspan=2>浮点数型</td>
<td>单精度型</td>
</tr>
<tr>
<td>双精度型</td>
</tr>
<tr>
<td colspan=2>字符型</td>
</tr>
<tr>
<td colspan=2>枚举类型</td>
<tr>
<td rowspan=3>构造类型</td>
<td colspan=2>数组类型</td>
</tr>
<tr>
<td colspan=2>结构体类型</td>
</tr>
</tr>
<tr>
<td colspan=2>共用体类型</td>
</tr>
<tr>
<td colspan=3>指针类型</td>
</tr>
<tr>
<td colspan=3>空类型</td>
</tr>
</table>

## 3.2 常量与变量

### 3.2.1 常量和符号常量

* 常量：值不能改变的量，分为整形常量(12、0、-3)，实型常量(4.6、-1.23)，字符常量('a'、'd')，又叫字面常量或者直接常量
* 宏定义

```c
# define PRICE 35
```

* 这种用一个标识符代表一个常量的符号(宏定义)，成为符号常量，即以标识符形式出现的常量
* 符号常量名用大写，变量名用小写

## 3.2.2 变量

<p>变量代表内存中具有特定属性的一个存储单元，用来存放数据，也就是变量的值</p>
<p>变量名和变量值是两个概念</p>
<p>变量名实际上是以一个名字对应，代表一个地址</p>
<p>C语言规定标识符只能由字母、数字和下划线组成，且首字母必须是字母或者下划线</p>

## 3.3 整型数据

### 3.3.1 整型常量的表示方法 

* 整型常量即整常数(talbe 上紧挨着一行*开头就会正常解析幂符号 原因未知)
<table>
<tr>
<th>进制</th>
<th>表示方式</th>
<th>举例</th>
<th>换算成十进制</th>
</tr>
<tr>
<td rowspan=2>十进制</td>
<td rowspan=2>无特殊标识</td>
<td>123</td>
<td></td>
</tr>
<tr>
<td>-456</td>
<td></td>
</tr>
<tr>
<td rowspan=2>八进制</td>
<td rowspan=2>以0开头</td>
<td>0123</td>
<td><pre>1 x 8^2 + 2 x 8^1 + 3 x 8^0 = 83</pre></td>
</tr>
<tr>
<td>-11</td>
<td><pre>-(1 x 8^1 + 1 x 8^0) = -9</pre></td>
</tr>
<tr>
<td rowspan=2>十六进制</td>
<td rowspan=2>以0x开头</td>
<td>0123</td>
<td><pre>1 x 16^2 + 2 x 16^1 + 3 x 16^0 = 291</pre></td>
</tr>
<tr>
<td>-0x12</td>
<td><pre>-( 1 x 16^1 + 2 x 16^0 ) = -18</pre></td>
</tr>
</table>


### 3.3.2 整型变量

#### 3.3.2.1 整型数据在内存中的存放形式

* 数据在内存中以二进制形式存放，定义一个整型变量方式如下:

```c
int i; /* 定义为整型变量 */
i = 10; /* 给i赋值 */
```

<p>十进制数10的二进制形式为: 1010</p>
<p>Turbo C 2.0 和 Turbo C++ 3.0 为一个整型变量在内存中分配两个字节的存储单元。</p>
<p>Visual C++ 6.0 为整型变量分配4个字节的存储单元。</p>
<p>不同的编译系统为整型数据分配的字节数是不同的。</p>
<p>本书在举例时一般假定整型变量在内存中占用两个字节。</p>
<p>* 实际上，数值是以补码(complement)表示的。</p>
<p>一个正整数的补码和该数的原码(即该数的二进制形式)相同。</p>
<p>求负数的补码的方法：将该数的绝对值的二进制形式按位取反再加1。</p>

* -10的补码计算过程如下：
<table>
<tr><th>步骤</th><th>二进制形式</th></tr>
<tr><td>-10绝对值原码</td><td><pre>0000 0000 0000 1010</pre></td></tr>
<tr><td>按位取反</td><td><pre>1111 1111 1111 0101</pre></td></tr>
<tr><td>加1得补码(complemnt)</td><td><pre>1111 1111 1111 0110</pre></td></tr>
</table>

<p>在存放整数的存储单元中，最左面的一位用来表示符号，0代表正，1代表负。</p>

* 附上int型变量取值范围在内存中的存储码( -2^15 至 2^15 - 1 )：
<table>
<tr>
<th></th><th></th><th>原值</th>
<th>二进制形式</th>
</tr>
<tr>
<td>最小</td><td>-2^15</td><td>-32768</td>
<td><pre>1000 0000 0000 0000</pre></td>
</tr>
<tr>
<td>最小</td><td>-2^15 + 1</td><td>-32767</td>
<td><pre>1000 0000 0000 0001</pre></td>
</tr>
<tr>
<td>最小</td><td>-2^15 + 2</td><td>-32766</td>
<td><pre>1000 0000 0000 0010</pre></td>
</tr>
<tr>
<td></td><td>-3</td><td>-3</td>
<td><pre>1111 1111 1111 1101</pre></td>
</tr>
<tr>
<td></td><td>-2</td><td>-2</td>
<td><pre>1111 1111 1111 1110</pre></td>
</tr>
<tr>
<td></td><td>-1</td><td>-1</td>
<td><pre>1111 1111 1111 1111</pre></td>
</tr>
<tr>
<td></td><td>0</td><td>0</td>
<td><pre>0000 0000 0000 0000</pre></td>
</tr>
<tr>
<td></td><td>1</td><td>1</td>
<td><pre>0000 0000 0000 0001</pre></td>
</tr>
<tr>
<td></td><td>2</td><td>2</td>
<td><pre>0000 0000 0000 0010</pre></td>
</tr>
<tr>
<td></td><td>3</td><td>3</td>
<td><pre>0000 0000 0000 0011</pre></td>
</tr>
<tr>
<td>最大</td><td>2^15 - 3</td><td>32765</td>
<td><pre>0111 1111 1111 1101</pre></td>
</tr>
<tr>
<td>最大</td><td>2^15 - 2</td><td>32766</td>
<td><pre>0111 1111 1111 1110</pre></td>
</tr>
<tr>
<td>最大</td><td>2^15 - 1</td><td>32767</td>
<td><pre>0111 1111 1111 1111</pre></td>
</tr>
</table>

#### 3.3.2.2 整型变量的分类

<p>整型变量基本类型是int。</p>

* 在int之前可以加修饰符(modifier)：short，long，signed，unsigned

<table>
<tr>
<th>分类</th>
<th>表示方式</th>
<th>比特位</th>
<th>表达范围</th>
<th>-</th>
</tr>
<tr>
<td>有符号整数</td>
<td>[signed] int</td>
<td>16</td>
<td>-2^15 ~ 2^15 - 1</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>无符号整数</td>
<td>unsigned int</td>
<td>16</td>
<td>-2^16 ~ 2^16 - 1</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>有符号短整数</td>
<td>[signed] short [int]</td>
<td>16</td>
<td>-2^15 ~ 2^15 - 1</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>无符号整数</td>
<td>unsigned short [int]</td>
<td>16</td>
<td>-2^16 ~ 2^16 - 1</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>无符号整数</td>
<td>[signed] long [int]</td>
<td>32</td>
<td>-2^31 ~ 2^31 - 1</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>无符号整数</td>
<td>unsigned long [int]</td>
<td>32</td>
<td>-0 ~ 2^32 - 1</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
</table>

#### 3.3.2.3 整型变量的定义

<p>强制类型定义：C语言要求变量必须定义。</p>

<a herf="https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/406066?fr=aladdin">有效数字 : https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/406066?fr=aladdin</a>

<p>对变量的定义一般放在函数开头部分的声明部分。</p>
<p>也可以放在某一段分程序内，同时其作用域也只限于这段分程序内。</p>

* 例3.2 整型变量的定义与使用

```c
# include <stdio.h>
void main() {
	int a,b,c,d;
	unsigned u;
	a = 12;
	b = -24;
	u = 10;
	c = a + u;
 	d = b + u;
	printf("a + u = %d, b + u = %d\n", c, d);//a + u = 22, b + u = -14
}
```
<p>不同种类的整型数据可以进行算术运算。</p>
<p>本例是int与unsigned int进行相加减运算。</p>

#### 3.3.2.4 整型数据的溢出

* 例 3-3 整型数据的溢出

```c
# include <stdio.h>
void main() {
	int a,b;
	a = 32767;
	b = a + 1;

	printf("sizeof(a) = %d\n", sizeof(a));
	printf("sizeof a = %d\n", sizeof a);
	printf("sizeof(int) = %d\n", sizeof(int));
	//printf("sizeof int = %d\n", sizeof int);//这个语法不允许

	printf("a = %d, b = %d\n", a, b);//a = 32767, b = 32768

	a = 2147483647;
	b = a + 1;

	printf("a = %d, b = %d\n", a, b);//a = 2147483647, b = -2147483648
}
```
<p>原来的教材当时int是两字节，现在是4字节。所以为了演示溢出效果要用有符号4字节的最大值+1才行。</p>
<p>C语言的运算，溢出但是没报错，需要程序员自己注意。</p>

### 3.3.3 整型常量的类型

#### 3.3.3.4 unsigned int

<p>一个整常量后面加一个字母u或者U，认为是unsigned int型，在内存中按照unsigned int规定的方式存放，存储单元中最高位不作为符号位，而用来存储数据</p>
<p>如果写成-123445u，则先将-12345转换成其补码53191，然后按照无符号数存储</p>

#### 3.3.3.5 long int

<p>在一个整常量后面加一个字l或者L，则认为是long int型常量，如123l，432L，0L等</p>
<p>常用于函数调用中，如果函数形参是long int型，则要求实参也为long int型</p>

## 3.4 浮点型数据

<p>实数是个数学概念，这里补充下数的分类(深入了解见<<数论>>)：</p>

<pre>单数(odd numbers / singular)</pre>
<p>数学中正奇数的别称，可以表示为2n+1(n为>=0的整数)</p>

<pre>双数(even numbers)</pre>
<p>数学中正偶数的别称，与单数相对</p>

<pre>自然数(natural number)</pre>
<p>自然数，又叫非负整数，是指用以计量事物的件数或表示事物次序的数。</p>
<p>即用数码0，1，2，3，4……所表示的数。自然数由0开始，一个接一个，组成一个无穷的集体。</p>
<p>自然数有有序性，无限性。</p>
<p>分为偶数和奇数，合数和质数等。</p>

<pre>整数(integer)</pre>
<p>整数（integer），是正整数、零、负整数的集合。</p>
<p>整数的全体构成整数集，整数集是一个数环。</p>
<p>在整数系中，零和正整数统称为自然数。</p>
<p>-1、-2、-3、…、-n、…（n为非零自然数）为负整数。</p>
<p>则正整数、零与负整数构成整数系。</p>
<p>整数不包括小数、分数。如果不加特殊说明，所涉及的数都是整数，所采用的字母也表示整数。</p>
<p>整数可以看作分母为1的分数。</p>

<pre>有理数(rational number)</pre>
<p>有理数是整数（正整数、0、负整数）和分数的统称，是整数和分数的集合。</p>
<p>有理数,包含整数及小数（不包含无限不循环小数）,通俗理解就是可以写成分数形式的数,所有有理数都可以用分数表示.</p>

<pre>无理数(irrational number)</pre>
<p>不是有理数的实数称为无理数，即无理数的小数部分是无限不循环的数。</p>
<p>即无限不循环小数,不可以用分数形式表示.如圆周率,根号2等.</p>

<pre>实数(real number)</pre>
<p>实数就是有理数和无理数的统称，或代数数和超越数两类。</p>
<p>实数集通常用黑正体字母 R 表示。</p>
<p>实数是不可数的。</p>
<p>其余特性见：https://baike.baidu.com/item/%E5%AE%9E%E6%95%B0/296419?fr=ge_ala</p>
<p>实数是实数理论的核心研究对象。</p>
<p>所有实数的集合可称为实数系（real number system）或实数连续统。</p>
<p>任何一个完备的阿基米德有序域均可称为实数系。</p>
<p>在保序同构意义下它是惟一的，常用R表示。</p>
<p>由于R是定义了算数运算的运算系统，故有实数系这个名称。</p>
<p>实数可以用来测量连续的量。</p>
<p>理论上，任何实数都可以用无限小数的方式表示，小数点的右边是一个无穷的数列（可以是循环的，也可以是非循环的）。</p>
<p>在实际运用中，实数经常被近似成一个有限小数（保留小数点后 n 位，n为正整数）。</p>
<p>在计算机领域，由于计算机只能存储有限的小数位数，实数经常用浮点数来表示。</p>

<pre>虚数(imaginary number)</pre>
<p>在数学中，虚数就是形如a+b×i的数，其中a，b是实数，且b≠0，i² = - 1。</p>
<p>虚数这个名词是17世纪著名数学家笛卡尔创立，因为当时的观念认为这是真实不存在的数字。</p>
<p>后来发现虚数a+b×i的实部a可对应平面上的横轴，虚部b可对应平面上的纵轴，这样虚数a+b×i可与平面内的点(a,b)对应。</p>
<p>可以将虚数bi添加到实数a以形成形式a + b×i的复数，其中实数a和b分别被称为复数的实部和虚部。</p>
<p>一些作者使用术语纯虚数来表示所谓的虚数，虚数表示具有非零虚部的任何复数。</p>

<pre>复数(complex number)</pre>
<p>实数和虚数共同构成复数。</p>
<p>复数是指能写成如下形式的数a+bi,这里a和b是实数,i是虚数单位（即-1开方）比如：根的判别式小于0的一元二次方程的根.</p>
<p>复数是指形如 z=a+bi 的数，其中a称为实部，b称为虚部，i称为虚数单位。</p>
<p>当 b=0 时，z为实数</p>
<p>当 b<>0 & a=0 时，z为纯虚数。</p>
<p>复数域是实数域的代数闭包，即任何复系数多项式在复数域中总有根。</p>

<pre>有效数字(significant digit)</pre>
<p>具体地说，有效数字是指在分析工作中实际能够测量到的数字。</p>
<p>能够测量到的是包括最后一位估计的，不确定的数字。 </p>
<p>我们把通过直读获得的准确数字叫做可靠数字；把通过估读得到的那部分数字叫做存疑数字。</p>
<p>把测量结果中能够反映被测量大小的带有一位存疑数字的全部数字叫有效数字。</p>
<p>测得物体的长度5.15cm。</p>
<p>数据记录时，我们记录的数据和实验结果真值一致的数据位便是有效数字。</p>
<p>另外在数学中，有效数字是指从一个数的左边第一个非0数字起，到末位数字止，所有的数字都是这个数的有效数字，如0.618的有效数字有三个，分别是6,1,8。</p>
<p>舍入规则：当保留n位有效数字，</p>
<p>若第n+1位数字≤4就舍掉。</p>
<p>若第n+1位数字≥6时，则第n位数字进1。</p>
<p>若第n+1位数字=5且后面数字为0时 ，则第n位数字若为偶数时就舍掉后面的数字，若第n位数字为奇数时加1；</p>
<p>若第n+1位数字=5且后面还有不为0的任何数字时，无论第n位数字是奇或是偶都加1。</p>

### 3.4.1 浮点型常量的表示方法

<p>C语言中的浮点数(float point number)指实数(real number)，浮点数有两种表示形式：</p>

* 十进制小数表示形式。它由数字和小数点组成(注意必须有小数点)。0.123、123.、123.0、0.0都是十进制小数形式。
* 指数形式。如123e3，或者123E3，都代表123X10^3。 注意字母e/E之前必须有数字，且e后面的指数必须为整数，如e3、2.1e3.5、.e3、e等都是不合法的指数形式。

<p>一个浮点数可以有多种指数表示形式。如123.456可以表示为：123.456e0、12.3456e^1、1.23456e^2、0.123456e^3、0.0123456e^4、0.00123456e^5。其中1.23456e^2称为 <u>规范化的指数形式</u>。即在字母e/E之前的小数部分中，小数点左边应有且只有一位非零的数字。</p>
<p>浮点数在以指数形式输出时，是按照规范化的指数形式输出的。如：如果指定将实数5689.65按照指定形式输出，是5.68965e+003。</p>

### 3.4.2 浮点型变量

#### 3.4.2.1 浮点型数据在内存中的存放形式

<p>一个浮点型数据在内存中占用四个字节(旧)。与整型数据不同，浮点型数据按照指数形式存储。系统把一个浮点型数据分成小数部分和指数部分分别存放。实数3.14159在内存中的存放形式：</p>

* 图 3-7
<table>
<tr>
<td><pre/>+</pre></td>
<td><pre>.314159</pre></td>
<td><pre>1</pre></td>
</tr>
<tr>
<td>数符</td>
<td>小数部分</td>
<td>指数</td>
</tr>
<tr>
<td colspan=3>+ .314159 x 10^1 = 3.14159</td>
</tr>
</table>

<p>图3-7中使用十进制数来示意的，实际上在计算机中是用二进制数来表示小数部分以及用2的幂次来表示指数部分的。</p>

<p>在四个字节中多少位用来表示小数部分，多少位表示指数部分，标准没有具体规定，有各C语言编译系统自定。不少C语言编译系统用24位表示小数(包括符号)，8位表示指数(包括指数的符号)。</p>

<p>小数半部分占的位越多，数字的有效数字越多，精度越高。指数部分占的位数越多，能表示的数值范围越大。</p>

#### 3.4.2.2 浮点型变量的分类

<p>浮点型数据分类如下：</p>

* 表 3-2 浮点型数据
<table>
<tr>
<th>类型</th>
<th>比特位</th>
<th>有效数字</th>
<th>数值范围</th>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>6 ~ 7</td>
<td>-3.4 x 10^-38 ~ -3.4 x 10^38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>15 ~ 16</td>
<td>-1.7 x 10^-308 ~ -1.7 x 10^308</td>
</tr>
<tr>
<td>long double</td>
<td>128</td>
<td>18 ~ 19</td>
<td>-1.2 x 10^-4932 ~ -1.2 x 10^4932</td>
</tr>
</table>

<p>ANSI C 并未规定每种类型的长度、精度和数值范围。有的系统将double类型增加的32位全用于存放小数部分，这样可以增加数值的有效位数，减少舍入误差。有的系统则将增加的bit位的一部分用于存放指数部分，这样可以扩大数值的范围。表3-2列出的是Turbo C、Turbo C++ 6.0、MS C的情况，不同的系统会有差异。</p>

#### 3.4.2.3 浮点型变量的舍入误差

<p>由于浮点型变量是由有限的存储单元组成，因此提供的有效数字总是有限的。在有效位以外的数字将会被舍去。这可能会产生一些误差。</p>

* 例 3-4 浮点型数据的舍入误差

```c
#include <stdio.h>

void main()
{
  float a,b;
  a = 123456.789e5;
  b = a + 20;
  printf("a = %f\n", a);
  printf("b = %f\n", b);
}
```

<p>程序内printf函数中的 "%f" 是输出浮点数时指定的格式符，作用是指定该实数以小数形式输出。</p>

<p>程序运行时输出的b的值与a相等，原因是：a的值比20大很多，a+20的理论值应该是12345678920，而一个浮点型变量只能保证有效的数字是7位，后面的数字是无意义的，因而并不能准确的表示该数。</p>

<p>运行程序可以看到前8位是准确的，后几位是不准确的，把20加在后几位上，是无意义的。</p>

<p>应当避免将一个很大的数和一个很小的数相加减，否则就会“丢失”小的数。</p>

<p>与此类似，用程序计算 1.0/3.0*3 的结果并不等于1。</p>

### 3.4.3 浮点型常量的类型

<p>C语言编译系统将浮点型常量作为双精度来处理。例如已定义一个浮点型变量 f，有如下语句：</p>

```c
f = 2.45678 * 4523.65;
```

<p>系统先把 2.45678 和 4523.65 作为双精度数，然后进行相乘的运算，得到的乘积也是一个双精度数。最后取其前7位赋给浮点型变量 f。这样做可以使计算结果更精确。但是运算速度降低了。如果是在数的后面加字母 f 或者 F (如：1.65f、654.87F)，这样编译系统就会把它们按单精度(32位)处理。</p>

<p>一个浮点型常量可以赋值给一个 float 型、double 型、或者 long double 型变量，根据变量的类型截取实型变量中相应有效位数字。</p>

<p>假如 a 已指定为单精度浮点型变量：</p>

```c
float a;
a = 111111.111;
```

<p>由于 float 型变量只能接收7位有效数字，因此最后两位小数不起作用。如果 a 改为 double 型，则能全部接收上述 9 位数字并存储在变量 a 中。</p>

## 3.5 字符型数据

### 3.5.1 字符常量

<p>C语言的字符常量是用单撇号括起来的一个字符。如 `a`,`x`,`D`,`?`,`$`。</p>
<p>除了以上形式的字符串常量，C语言还允许用一种特殊形式的字符常量，就是 "\" 开头的字符。例如在 printf 函数中使用的 "\n"，它代表一个"换行符"，这是一种"控制字符"，在屏幕中不显示，在程序中也不能用一般形式的字符表示，只能用特殊形式表示。</p>

* 表 3-3 常用的转义字符及其作用
<table>
<tr>
<th>字符形式</th>
<th>含义</th>
<th>ASCII代码</th>
</tr>
<tr>
<td><pre>\n</pre></td>
<td>换行，将当前位置移到下一行开头</td>
<td>10</td>
</tr>
<tr>
<td><pre>\t</pre></td>
<td>水平制表(调到下一个Tab位置)</td>
<td>9</td>
</tr>
<tr>
<td><pre>\b</pre></td>
<td>退格，将当前位置移到前一列</td>
<td>8</td>
</tr>
<tr>
<td><pre>\r</pre></td>
<td>换行，将当前位置移到下一行开头</td>
<td>13</td>
</tr>
<tr>
<td><pre>\f</pre></td>
<td>换页，将当前位置移到下页开头</td>
<td>12</td>
</tr>
<tr>
<td><pre>\\\\</pre></td>
<td>代表一个反斜杠字符"\\"</td>
<td>92</td>
</tr>
<tr>
<td><pre>\'</pre></td>
<td>代表一个单引号(撇号)字符</td>
<td>39</td>
</tr>
<tr>
<td><pre>\\\"</pre></td>
<td>代表一个双引号字符</td>
<td>34</td>
</tr>
<tr>
<td><pre>\ddd</pre></td>
<td>1到3位被八进制数所代表的字符</td>
<td></td>
</tr>
<tr>
<td><pre>\xhh</pre></td>
<td>1到2位十六进制数所代表的字符</td>
<td></td>
</tr>
</table>


<p></p>
<p></p>
<p></p>

### 3.5.2 字符变量

<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

### 3.5.3 字符数据在内存中的存储形式及其使用方法

<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

### 3.5.4 字符串常量

<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

## 3.6 变量赋初值

## 3.7 各类数值型数据间的混合运算

## 3.8 算术运算符和算术表达式

### 3.8.1 C语言运算符简介

### 3.8.2 算术运算符和算术表达式

## 3.9 赋值运算符和赋值表达式

## 3.10 逗号运算符和逗号表达式

# 第四章 最简单的C程序设计--顺序程序设计

# 第五章 选择结构程序设计

# 第六章 循环控制

# 第七章 数组

## 7.1 一维数组的定义和引用

### 7.1.1 一维数组的定义

### 7.1.2 一维数组元素的引用

### 7.1.3 一维数组的初始化

### 7.1.4 一维数组程序举例

## 7.2 二维数组的定义和引用

### 7.2.1 二维数组的定义

### 7.2.2 二维数组的引用

### 7.2.3 二维数组的初始化

### 7.2.4 二维数组程序举例

## 7.3 字符数组

### 7.3.1 字符数组的定义

### 7.3.2 字符数组的初始化

### 7.3.3 字符数组的引用

### 7.3.4 字符串和字符串结束标志

### 7.3.5 字符数组的输入输出

### 7.3.6 字符串处理函数

### 7.3.7 字符数组应用举例

# 第八章 函数

## 8.1 概述

<p>一个较大的程序一般应分为若干个子模块，每个模块用来实现一个特定功能。所有的高级语言中都有子程序这个概念，用子程序来实现模块的功能。在C语言中，子程序的作用是函数来完成的。一个C程序可以有一个主函数和若干其他函数构成。主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或者多个函数调用任意次数。</p>
<p>在程序开发中，常将一些常用的功能模块编写成函数，放在公共函数库中供大家调用，以减少重复编写程序段的工作量。</p>

例8.1 函数调用的例子

```c
# include <stdio.h>

void main()
{
  void printstar(); /* 声明 printstar 函数 */
  void print_message(); /* 声明 print_message 函数 */
  printstar(); /* 调用 printstar 函数 */
  print_message(); /* 调用 print_message 函数 */
  printstar(); /* 调用 printstar 函数 */
}

void printstar() /* 定义 printstar 函数 */
{
  printf("* * * * * * * * * * * *\n");
}


void print_message() /* 定义 print_message 函数 */
{
  printf(" How do you do! \n");
}
```

<p>printstar 和 print_message 都是用户定义四的函数名。定义这两个函数时指定函数的类型巍峨 void，意为函数无类型，即无函数值，执行这两个函数后不会把任何值带回 main 函数。</p>
<p>说明：</p>
<p>(1) 一个C程序由一个或多个程序模块组成，每一个程序模块作为一个源程序文件。对较大的程序，一般不希望把所有内容全放在一个文件中，而是将它们分别放在若干个源文件中，再由若干个源程序文件组成一个C程序。这样便于分别编写、分别编译，提高调式效率。一个源程序文件可以为多个C程序共用。</p>
<p>(2) 一个源程序文件有一个或多个函数以及其他有关内容(如命令行、数据定义等)组成。一个源程序文件是一个编译单位，在程序编译时是以源程序文件为单位进行编译，而不是以函数为单位。</p>
<p>(3) C程序的执行是从 main 函数开始，如在 main 函数中调用其他函数，在调用后流程返回到 main 函数，在 main 函数中结束整个程序的运行。</p>
<p>(4) 所有函数都是平行的，即在定义函数时是分别进行的，是互相独立的。一个函数并不从属于另一个函数，即函数不能嵌套定义。函数间可以互相调用，但不能调用 main 函数。 main 函数是系统调用的。</p>
<p>(5) 从用户角度看函数有两种：</p>
<p>(5.1) 标准函数：即库函数，由系统提供，用户不必自己定义而直接使用。强调一下，不同C语言编译系统提供的库函数的数量和功能会有一些不同，当然许多基本的函数是共同的。。</p>
<p>(5.2) 用户自定义函数：用以解决用户专门需求的函数。</p>
<p>(6) 从函数的形式看：</p>
<p>(6.1) 无参函数：如例8.1中的 printstar 和 print_message。在调用无参函数时，主调函数不向被调用函数传递数据。</p>
<p>(6.2) 有参函数：主调函数在调用函数时，通过参数向被调用函数传递数据。</p>

## 8.2 函数定义的一般形式

### 8.2.1 无参函数定义的一般形式

```c
类型标识符 函数名()
{
  声明部分
  语句部分
}
```

<p>定义函数时要用"类型标识符"指定函数值的类型，即函数返回值的类型。</p>

### 8.2.2 有参函数定义的一版形式

```c
类型标识符 函数名(形式参数列表)
{
  声明部分
  语句部分
}
```

例如：

```c
int max(int x, int y) /* 默认函数类型为int， int可以省略 */
{
  int z; /* 函数体中的声明部分 */
  z = x > y ? x : y;
  return(z);
}
```

<p>如果在定义函数时不指定函数类型，系统会隐含指定函数类型为int型。因此上面定义的 max 函数左端的 int 可以省略。</p>

### 8.2.3 空函数

<p>在程序设计中会用到空函数，形式如下：</p>

```c
类型说明符 函数名()
{ }
```
如：

```c
void dummy()
{ }
```

<p>此函数被调用时不做任何工作。在主调函数中写上 "dummy();" 表明这里需要调用一个函数，而现在这个函数没有起作用，等以后扩充函数功能时补上。</p>
<p>在程序设计中往往要确定若干模块，分别由若干函数实现。而在第一阶段只设计最基本的模块，其他次要功能则在以后陆续补上。在初始阶段，在将来准备扩充功能的地方写上一个空函数(函数名去将来采用的实际函数名，如：merge 等)，先占一个位置，以后用编好的函数代替它。这样做，程序结构清晰，可读性强，方便以后扩充新功能，对程序结构影响不大，空函数在程序设计中很常见。</p>

## 8.3 函数参数和函数的值

### 8.3.1 形式参数和实际参数

<p>在调用函数时，大多数情况下，主调函数和被调用函数之间有数据传递关系。这就是前面提到的有参函数。在定义函数时函数名后面括号中农的把变量名称为"形式参数"，简称"形参"。在主调函数中调用一个函数时，函数名后面括号中的参数(可以是一个表达式)称为"实际参数"，简称"实参"。</p>

<p>例8.2 函数调用时的数据传递。</p>

```c
# include<stdio.h>

void main()
{
	int max(int x, int y); /* 声明 max(int) 函数 */
	int a,b,c;
	scanf("%d, %d", &a, &b);
	c=max(a, b); /* 这里的 a,b 是实参 */
	printf("Max is %d", c);
}

int max(int x, int y) /* 定义 max(int) 函数， x，y是形参 */
{
	int z;
	z = x > y ? x : y;
	return (z);
}
```

<p>关于形参与实参的说明：</p>
<p>(1) 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。只有在发生函数调用时，函数 max 中的形参才被而分配内存单元。在调用结束后，形参所占内存单元也被释放。</p>
<p>(2) 实参可以是常量、变量或表达式，如：</p>

```c
max(3, a + b);
```

<p>但要求他们有确定的值。在调用函数时将实参的值赋给形参。</p>

<p>(3) 在被定义的函数中，必须指定形参的类型。</p>
<p>(4) 实参与形参的类型应相同或赋值兼容。如果实参为整型，而形参x为实数型，则按照第三章介绍的不同类型数值的赋值规则进行转换。在上面的例子中，应将max函数放在main函数前面，或者在main函数中对max函数进行原型声明，否则会报错。字符型与整型可以互相通用。</p>
<p>(5) C语言规定，实参变量对形参标量的数据传递是"值传递"，即单向传递。只由实参传给形参，而不能由形参传回来给实参。在内存中，实参单元与形参单元是不同的单元。</p>
<p>在调用函数时，给形参分配存储单元，并将实参对应的值传递给形参，调用结束后，形参单元被释放，实参单元保留并维持原值。在执行一个被调用函数时，形参的值如果发生改变，不会影响主调函数的实参的值。</p>

### 8.3.2 函数的返回值

<p>通常，希望通过函数调用使主调函数得到一个	确定的值，这就是函数的返回值。下面对函数值做一些说明：</p>
<p>(1) 函数的返回值是通过函数中的return语句获得的。return语句将被调用函数中的一个确定值带回主调函数中去。</p>
<p>如果需要从	被调用函数带回一个函数值(供主调函数使用)，被调用函数中必须包含return语句。如果不需要从被调用函数带回函数值可以不要return语句。</p>
<p>一个函数中可以有一个以上的return语句，执行到哪一个return语句，哪一个语句起作用。</p>
<p>return语句后面的括弧也可以不要，如：</p>

```c
return z;
```

<p>它与"return (z);"等价。</p>
<p>return后面的值可以是一个表达式。例如：例8.2中的函数max可以改写如下：</p>

```c
max(int x, int y)
{
	return (x > y ? x : y);
}
```

<p>这样函数体更为简短，一个return语句就把求值和返回都解决了。</p>

<p>(2) 函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的类型。如：</p>

```c
int max(float x, float y); /* 函数值为整型 */
char letter(char c1, char c2); /* 函数值为字符型 */
double min(int x, int y); /* 函数值为双精度型 */
```

<p>例8.2中的函数定义并没有说明其类型，这是因为C语言规定，凡是不加类型说明的函数，一律自动按整型处理。例8.2中的max函数返回值为整型，因此可以不必说明。建议在定义时对所有函数都指定函数类型。</p>

<p>(3) 在定义函数时对指定的函数类型一般应该和return语句中的表达式类型一致。</p>

<p>如果函数值的类型和return语句中的表达式类型不一致，则以函数类型为准。对数值型数据，可以自动进行类型转换。即函数类型决定返回值的类型。</p>

<p>例8.3 返回值类型与函数类型不同。将例8.2稍作改动(注意是变量的类型改动)。</p>

```c
# include<stdio.h>

void main()
{
	int max(float x, float y); /* 声明 max(int) 函数 */
	float a, b;
	int c;
	scanf("%f, %f", &a, &b);
	c=max(a, b); /* 这里的 a,b 是实参 */
	printf("Max is %d", c);
}

int max(float x, float y) /* 定义 max(float, float) 函数， x，y是形参 */
{
	float z; /* z是实型变量 */
	z = x > y ? x : y;
	return (z);
}
```

<p>函数max定义为整型，而return语句中的z为实型，二者不一致，按上述规定，现将z转换为整型，然后max(x, y)带回一个整型值2返回主调函数main。如果将main函数中c定义为实型，用%f格式符输出，也是 2.000000。</p>
<p>有时，可以利用这一特点进行类型转换。如：在函数中进行实型运算，希望返回的是整型，可以让系统自动完成类型转换。单这种做法往往使程序不清晰，降低可读性，易错，且并不是所有类型都能互相转换(如：实数与字符类型数据之间)。不建议初学者使用这种方式，而应做到使函数类型与return返回值的类型一致。</p>
<p>对于不带返回值的函数，应好用 "void" 定义函数为“无类型”(或者“空类型”)。这样系统就保证不使函数带回任何值，即禁止在调用函数中使用被调用函数的返回值。此时在函数体中不得出现return语句。</p>

## 8.4 函数的调用

### 8.4.1 函数调用的一般形式

```c
函数名(实参列表);
```

<p>调用无参函数，"实参列表"可以没有，但括号不能省略。实参列表的多个参数间用逗号隔开。实参应与形参个数相等，类型匹配。如实参列表包括多个实参，对实参的求值顺序是不确定的。</p>

例 8.4 实参求值的顺序

```c
#include <stdio.h>

void main()
{
    int f(int a, int b); /* 函数声明 */
    int i = 2, p;
    p = f(i, ++i); /* 函数调用 */
    printf("%d\n", p);
}

int f(int a, int b)
{
    int c;
    if(a > b)c = 1;
    else if(a == b)c = 0;
    else c = -1;
    return (c);
}
```

<p>如果按自左而右的顺序求实参的值，则函数调用相当于是f(2, 3)，则函数值为 -1。若按照自右而左顺序求值，则相当于是f(3, 3)，函数值为 0。</p>
<p>不同的编译系统实现不同，应当避免使用这种影响通用性的编程方式。可以在函数调用前先求出值。</p>

```c
j = i;
k = ++i;
p = f(j, k);
```

### 8.4.2 函数调用的方式

<p>按照函数在程序中出现的位置分，分以下三种函数调用方式：</p>


<p>1. 函数语句</p>
<p>把函数调用作为一个语句，如例 8.1 中的 "printstar();" ，这时不要求函数带回返回值，只要求函数完成一定的操作。</p>
<p>2. 函数表达式</p>
<p>函数出现在一个表达式中，这种表达式称为函数表达式。这时要求函数带回一个确定的值已参与表达式的运算。例如：</p>

```c
c = 2 * max(a, b);
```

<p>3. 函数参数</p>
<p>函数调用作为一个函数的参数。例如：</p>

```c
c = 2 * max(a, max(b, c));
```

<p>又如：</p>

```c
printf("%d", max(a, b));
```

<p>函数调用作为函数的参数，实质上也是函数表达式形式调用的一种，因为函数的参数本来就要求是表达式形式。</p>

### 8.4.3 对被调用函数的声明和函数原型

<p>在一个函数中调用另一个函数(即被调用函数)需要具备的条件如下。</p>
<p>(1)首先被调用的函数必须是已经存在的函数(是库函数或用户自己定义的函数)。</p>
<p>(2)如果使用库函数，还应该在本文件开头用 #include 命令将调用有关库函数时所需用到的信息"包含"到本文件中来。例如：前几章中已经用到过的命令：</p>

```c
#include<stdio.h>
```

<p>其中"stdio.h"是一个头文件。在stdio.h文件中包含了输入输出库函数所用到的一些宏定义信息，不包含就无法使用。同样，使用数据学库中的函数，就应该用：</p>

```c
#include<math.h>
```

<p>(3)如果使用用户自己定义的函数，而该函数的位置在调用他的函数(即主调函数)的后面(在同一个文件中)，应该在主调函数中对被调用的函数作声明。</p>
<p>"声明"一词的原文是 declaration ，过去在许多书中把它译为"说明"，现在越来越多的计算机专家提出应译为声明，更确切，表意更清楚。声明的作用是把函数名、函数参数的个数和参数类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数并检查调用是否合法。</p>
<p>例8.5 对被调用函数的声明。</p>

```c
#include <stdio.h>

void main()
{
    float add(float x, float y); /* 对被调用函数 add 的声明 */
    float a, b, c;
    scanf("%f, %f", &a, &b);
    c = add(a, b);
    printf("sum is %f\n", c);
}

float add(float x, float y) /* 函数首部 */
{
    float z; /* 函数体 */
    z = x + y;
    return (z);
}
```

<p>上面例子中的函数声明，可以不写形参名，只写形参的类型。如：</p>


```c
float add(float, float);
```

<p>编译系统只检查参数个数和参数类型，不检查参数名。</p>
<p>以上的函数声明称为函数原型(function prototype)。使用函数原型是 ANSI C 的一个重要特点。见例 8.5，main函数的位置在add函数的前面，而在进行编译时是从上到下逐行进行的，如果没有对函数的声明，当编译到调用 add 函数的那一行时，编译系统无法确定 add 是不是函数名，也饿无法判断实参(a，b)的类型和个数是否正确，因而无法进行正确性的检查。如果不做检查，在运行时才发现实参和形参的类型或个数不一致，出现运行错误。但是在运行阶段发现错误并重新调试程序，是比较麻烦的，工作量也较大。应当在编译阶段尽可能的多发现错误，并随之纠正。</p>
<p>现在，在函数调用之前用函数原型做了函数声明。因此编译系统记下了所需调用的函数的有关信息，在对"c = add(a, b);" 进行编译时就"有章可循"了。编译系统根据函数的原型对函数调用的合法性进行全面的检查。与函数原型不匹配的函数调用会导致编译出错，它属于语法错误。</p>
<p>注意：对函数的"定义"和"声明"不是一回事。函数的定义是指对函数功能的确立，不包括指定函数名、函数值类型、形参及其类型、函数体等，它是一个完整的、独立的函数单位。而函数的声明的作用则是把函数的名字、函数类型以及形参的个数、类型和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查。</p>
<p>函数声明的一般形式有两种：</p>
<p>(1) 函数类型 函数名(参数类型1, 参数类型2, ..., 参数类型N);</p>
<p>(2) 函数类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ..., 参数类型N 参数名N);</p>
<p>第一种是基本形式。为了便于阅读，也允许在函数原型中加上参数名，就形成了第二种形式。但是编译系统不检查参数名，因此参数名是什么都无所谓。</p>
<p>需要保证函数声明和函数定义的首部写法上的一致，即函数类型、函数名、参数个数、参数了诶性和参数顺序必须相同。函数调用时的函数名、实参个数、实参顺序与函数原型一致。实参类型必须与函数原型中的形参类型赋值兼容(按照第三章介绍的赋值规则进行类型转换)。否则就按照出错处理。</p>
<p>用函数原型来声明函数，能减少编写程序时可能出现的错误。由于函数声明的位置与函数调用语句的位置比较接近，在写程序时便于就近参照函数原型来书写函数调用，不易出错。</p>
<p>说明：</p>
<p>(1)以前C语言版本的函数声明不是采用函数原型，而只声明函数名和函数类型。例如在例 8.5 中采用下面的函数声明方式：</p>

```c
float add();
```

<p>不包括参数类型和参数个数。系统不检查参数类型和个数。新版本也兼容这种用法，但是不提倡这种用法，因为它未对函数调用的合法性进行全面的检查。</p>

<p>(2)如果被调用的函数的定义在主调函数之前，可以不必加以声明。因为编译系统已经先知道了已定义函数的有关情况，会根据函数首部提供的信息对函数的调用作正确性检查。例 8.5 可以改造如下：</p>


```c
#include <stdio.h>

float add(float x, float y) /* 函数首部 */
{
    float z; /* 函数体 */
    z = x + y;
    return (z);
}

void main() /* 不必对被调用函数 add 作声明 */
{
    float a, b, c;
    scanf("%f, %f", &a, &b);
    c = add(a, b);
    printf("sum is %f\n", c);
}
```

<p>(3)如果已在文件的开头(在所有函数之前)，已对本文件中所调用的函数进行了声明，则在各函数中不必对其所调用的函数再做声明。例如：</p>

```c
char letter(char, char); /* 以下三行在所有函数之前，且在函数外部 */
float f(float, float);
int i(float, float);

void main() /* 在 main 函数中要调用 letter、f、i，不必对它所调用的三个函数进行声明 */
{
...
}

/* 下面定义被 main 函数调用的3个函数 */
char letter(char c1, char c2) /* 定义 letter 函数 */
{
...
}

float f(float x, float y) /* 定义 f 函数 */
{
...
}

int i(float j, float k) /* 定义 i 函数 */
{
...
}
```

<p>(4)如果被调用的函数类型为整型，C语言允许在调用函数前不必作函数原型声明。如例 8.4 可以写成如下形式：</p>

```c
#include <stdio.h>

void main()
{ /* 可以没有函数声明 */
    int i = 2, p;
    p = f(i, ++i); /* 函数调用 */
    printf("%d\n", p);
}

f(int a, int b) /* 定义整型函数，省写了类型标识符 int */
{
    int c;
    if(a > b)c = 1;
    else if(a == b)c = 0;
    else c = -1;
    return (c);
}
```

<p>但是使用这种方法，系统无法对函数参数的个数和类型进行检查。若调用函数时参数使用不当，在编译时也不会报错，而在运行时出错。而且，Turbo C和Visual C++要求对所有被调用的函数进行声明。为了程序清晰和安全及通用性，编写程序时最好都加上函数原型声明。</p>

## 8.5 函数的嵌套调用

<p>C语言的函数定义是互相平行、独立的，定义函数时，一个函数内不能包含另一个函数。</p>
<p>C语言不能嵌套定义函数，但可以嵌套调用函数。</p>

## 8.6 函数的递归调用

<p>在调用一个函数的过程中又出现直接或间接地调用该函数本身，成为二函数的递归调用。C语言的特点之一就是允许函数的递归调用。</p>

## 8.7 数组作为函数参数

<p>可以用变量做函数参数，同样也可以用数组元素作函数参数，用法与变量相同。数组名也可以作实参和形参，传递的是数组首元素的地址。</p>

### 8.7.1 数组元素作函数实参

<p>实参可以是表达式，而数组元素可以是表达式的组成部分，因此数组元素当然可以作为函数的实参，与用变量作实参一样，是单向传递，即"值传递"的方式。</p>
<p>例 8.10 有两个数组a和b，各有10个元素，分别统计两个数组响应元素大于、等于、小于的次数。</p>

```c
#include<stdio.h>

void main()
{
    int largee(int x, int y);
    int a[10], b[10], i, r, n = 0, m = 0, k = 0;
    printf("enter array a : \n");
    for(i = 0; i < 10; i++)
        scanf("%d", &a[i]);
    printf("\n");
    printf("enter array b : \n");
    for(i = 0; i < 10; i++)
        scanf("%d", &b[i]);
    printf("\n");
    for(i = 0; i < 10; i++)
    {
        r = large(a[i], b[i]);
        if(r == 1)
            n = n + 1;
        else
            if(r == 0)
                m = m + 1;
            else
                k = k + 1;
    }
    printf("a[i] > b[i] %d times\n", n);
    printf("a[i] = b[i] %d times\n", m);
    printf("a[i] < b[i] %d times\n", k);
    if(n > k)
        printf("array a is larger to array b\n");
    else if(n < k)
        printf("array a is smaller to array b\n");
    else
        printf("array a is equal to array b\n");
}

large(int x, int y)
{
    int flag;
    if(x > y)
        flag = 1;
    else if(x < y)
        flag = -1;
    else
        flag = 0;
    return (flag);
}
```

### 8.7.2 数组名为函数参数

<p>可以用数组名作函数参数，此时形参应当用数组名或指针变量。</p>

```c
#include <stdio.h>

void main()
{
    float average(float array[10]);
    float score[10], aver;
    int i;
    printf("input 10 scores : \n");
    for(i = 0; i < 10; i++)
        scanf("%f", &score[i]);
    printf("\n");
    aver = average(score);
    printf("average score is %5.2f\n", aver);
}

float average(float array[10])
{
    int i;
    float aver, sum = array[0];
    for(i = 0; i < 10; i++)
        sum = sum + array[i];
    aver = sum / 10;
    return (aver);
}
```

<p>关于数组名作为函数参数的说明：</p>
<p>(1) 用数组名作为函数参数，应该在主调用函数和被调用函数分别定义数组，上例中array是形参数组名，score是实参数组名，分别在其所在函数中定义，不能只在一方定义。</p>
<p>(2) 实参数组与形参数组类型应一致，否则结果会出错。</p>
<p>(3) 在被调用函数中声明了形参数组的大小为10，实际上指定大小是不起任何作用的，因为C语言编译对形参数组大小不做检查，只是将实参数组的首元素地址传给形参数组。因此，形参数组名获得了实参数组的首元素地址。</p>
<p>(4) 形参数组可以不指定大小，在定义数组时在数组名后面跟一个空的方括号。有时为了在被调用函数中处理数组元素的需要，可以另设一个形参，传递需要处理的数组元素的个数。</p>

<p>例 8.12 形参数组不定义长度</p>

```c
#include <stdio.h>

void main()
{
    float average(float array[], int n);
    float score_1[5] = {98.5, 97, 91.5, 60, 55};
    float score_2[10] = {67.5, 89.5, 99, 69.5, 77, 89.5, 76.5, 54, 60, 99.5};
    int i;
    printf("the average of class A is %6.2f\n", average(score_1, 5));
    printf("the average of class B is %6.2f\n", average(score_2, 10));
}

float average(float array[], int n)
{
    int i;
    float aver, sum = array[0];
    for(i = 0; i < n; i++)
        sum = sum + array[i];
    aver = sum / n;
    return (aver);
}
```

<p>(5) 用数组名做函数实参时，不是把数组元素的值传递给形参，而是把实参数组的首元素的地址传递给形参数组，这样两个数组就共占同一段内存单元。也就是说，形参数组中各元素的值如果发生变化，会使实参数组元素的值同时发生变化。这一点是与变量作函数参数的情况不同。</p>

### 8.7.3 多维数组名作函数参数

<p>可以用多维数组名作为函数的实参和形参，在被调用函数中对形参数组定义时可以指定每一维的大小，也可以省略第一维的大小说明。例如：</p>

```c
int array[3][10];
```

或

```c
int array[][10];
```

<p>二者都是合法且等价的。但是不能把第二维以及其他高维的大小说明省略。如下面的定义是不合法的：</p>

```c
int array[][];
```

<p>之前已说明，二维数组是由若干个一维数组组成的，在内存中，数组是按行存放的，因此在定义二维数组时，必须指定列数(即一行中包含几个元素)，由于形参数组与实参数组类型相同，所以它们是由具有相同长度的一维数组所组成的。不能只指定第一维(行数)而忽略第二维(列数)，下面的写法是错误的：</p>

```c
int array[3][];
```

<p>在第二维大小相同的前提下，形参数组的第一维可以与实参数组不同。</p>
<p>这时形参数组和实参数组都是由相同类型和大小的一维数组组成。C语言编译系统不检查第一维的大小。</p>
<p>例 8.14 求一个3X4矩阵中所有元素的最大值</p>

```c
#include <stdio.h>

void main()
{
    int maxz_value(int array[][4]);
    int a[3][4] = {{1,3,5,7},{2,4,6,8},{15,17,34,12}};
    printf("max value is %d\n", max_value(a));
}

int max_value(int array[][4])
{
    int i, j, max;
    max = array[0][0];
    for(i = 0; i < 3; i++)
        for(j = 0; j < 4; j++)
            if(array[i][j] > max)
                max = array[i][j];
    return (max);
}
```

## 8.8 局部变量和全局变量

### 8.8.1 局部变量

<p>在一个函数内部定义的变量是【局部变量】，它只在本函数内部有效，在本函数以外不能使用它们。</p>
<p>说明：</p>
<p>(1) 主函数中的局部变量与普通函数中的局部变量作用域一致。主函数中定义的变量也只能在主函数中有效，主函数也不能使用其他函数中定义的变量。</p>
<p>(2) 不同函数的局部变量可以命名相同。它们代表不同的对象，在内存中占用不同的内存单元，互不混淆。</p>
<p>(3) 形式参数也是局部变量。</p>
<p>(4) 在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序”或“程序块”。</p>

```c
void main()
{ /* a, b在此范围内有效 */
    int a, b;
    ...
    { /* c在此范围内有效 */
        int c;
        c = a + b;
        ...
    }
    ...
}
```

<p>(5) 上例中变量c只在复合语句(分程序)内有效，离开复合语句该变量就无效，释放内存单元。</p>

### 8.8.2 全局变量(外部变量/全程变量)

<p>前面提过，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，在函数外定义的变量是外部变量，也叫全局变量、全程变量。全局变量可以为本文件中其它函数所共用。它的有效范围是从定义变量的位置开始到本源文件结束。</p>
<p>说明：</p>
<p>(1) 设置全局变量的作用是增加了函数间数据联系的渠道。由于同一文件中所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其它函数，相当于是各个函数间有直接的传递通道。由于函数的调用只能带回一个返回值，因此有时可以利用全局变量增加函数间的联系渠道，通过一次函数调用能得到一个以上的值。</p>
<p>为了便于区别全局变量和局部变量，在C程序设计人员中有一个不成文的约定(但非规定)，将全局变量名的第一个字母用大写表示。</p>

<p>例 8.15 有一个一维数组，内放10个学生成绩，写一个函数，求平均分、最高分和最低分。</p>
<p>显然希望通过函数调用得到3个结果值，除了可以从函数得到一个函数返回值外，还可以利用全局变量。</p>

```c
#include <stdio.h>

float Max = 0, Min = 0; /* 全局变量 */

void main()
{
    float average(float array[], int n);
    float ave, score[10];
    int i;
    for(i = 0; i < 10; i++)
        scanf("%f", &score[i]);
    ave = average(score, 10);
    printf("max = %6.2f\nmin = %6.2f\naverage = %6.2f\n", Max, Min, ave);
}

float average(float array[], int n) /* 定义函数，形参为数组 */
{
    int i;
    float aver, sum = array[0];
    Max = Min = array[0];
    for(i = 1; i < n; i++)
    {
        if(array[i] > Max) Max = array[i];
        if(array[i] < Min) Min = array[i];
        sum = sum + array[i];
    }
    aver = sum / n;
    return (aver);
}
```

<p>可以利用全局变量减少函数实参与形参的个数，从而减少内存空间以及传递数据时的时间消耗。</p>

<p>(2) 不建议在非必要时使用全局变量，原因如下。</p>
<p>(2.1) 全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟内存单元。</p>
<p>(2.2) 降低函数的通用性。函数在执行时依赖外部变量。移植函数时需要把有关的外部变量和值一起移植过去。如果在目标移植文件中遇到同名变量，就会出现问题，降低了程序的可靠性和通用性。在程序设计中要求模块“内聚性”强，与其它模块的“耦合性”弱。即要求模块功能单一，与其他模块的相互影响要尽量少，而全局变量是不符合这个原则的。一般要求把C程序中的函数做成一个封闭体，除了通过“形参-实参”的渠道与外界发生联系外，没有其它渠道。这样的程序移植性好，可读性强。</p>
<p>(2.3) 使用全局变量过多，会降低程序的清晰性，难以清楚的判断出每个瞬时各个外部变量的值。各个函数在执行时都可能改变外部变量的值，程序易出错。因此，要限制使用全局变量。</p>
<p>(3) 如果在同一个源文件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量被“屏蔽”，不起作用。</p>
<p>例 8.16 外部变量与局部变量同名</p>

```c
#include <stdio.h>

int a = 3, b = 5; /* a、b为外部变量 */

void main()
{
    int max(int a, int b); /* 本行为函数声明，a、b为形参名 */
    int a = 8; /* a为局部变量 */
    printf("%d\n", max(a, b));
}

int max(int a, int b) /* a、b为形参局部变量，作用域整个max函数 */
{
    int c;
    c = a > b ? a : b;
    return (c);
}
```

<p>故意重复使用a、b为变量名，注意区别不同a、b的含义和作用域。</p>
<p>形参也是局部变量，外部变量a、b在在max函数范围内不起作用。</p>

## 8.9 变量的存储类

### 8.9.1 动态存储方式和静态存储方式

<p>从变量的作用域(即从空间)角度来分，可以分为全局变量和局部变量。</p>
<p>从变量值的存在时间(即生存周期)角度来分，可以分为【静态存储方式】和【动态存储方式】。</p>
<p>所谓静态存储方式，是指在程序运行期间由系统分配固定的存储空间的方式。而动态存储方式则是在程序运行期间根据需要进行动态的分配存储空间的方式。</p>
<p>内存中供用户使用的存储空间，可以分为三部分，见图8-16</p>

<p>图 8-16</p>
<table>
<tr>
<td rowspan=3>用户区</td>
<td>程序区</td>
</tr>
<tr>
<td>静态存储区</td>
</tr>
<tr>
<td>动态存储区</td>
</tr>
<table>

<p>数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放。</p>
<p>在动态存储区中存放以下数据：</p>
<p>① 函数形式参数。在调用函数时给形参分配存储空间。</p>
<p>② 自动变量(未加static声明的局部变量)</p>
<p>③ 函数调用时的现场保护和返回地址等。</p>
<p>函数调用开始时分配动态存储空间，结束时释放这些空间。在程序执行过程中，这种分配是动态的，如果在一个程序中两次调用同一个函数，分配给此函数中的局部变量的存储空间地址可能是不同的。如果一个程序包含若干个函数，每个函数中的局部变量的生存周期并不等于整个程序的执行周期，它只是程序执行周期的一部分。根据函数调用的需要，动态的分配和释放存储空间。</p>
<p>在C语言中，每一个变量和函数有两个属性：数据类型和数据的存储类别。数据类型第三章讲过。存储类别是指数据在内存中的存储方式。分为两大类：静态存储和动态存储。具体包含四种：自动的 auto、静态的 static、寄存器的 register、外部的 extern。根据变量的存储类别，可以知道变量的作用域和生存周期。</p>

### 8.9.2 auto变量

<p>函数中的局部变量，如果不专门声明为 static，就都是动态分配存储空间的，数据存储在动态存储区中农。函数中的形参和在函数中定义的变量(包括在复合语句中定义的变量)，都属于此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时自动释放这些存储空间。因此这类局部变量称为自动变量。自动变量用关键字 auto 作为存储类别的声明。例如：</p>

```c
int f(int a) /* 定义 f 函数，a为形参 */
{
    auto int b, c = 3; /* 定义b、c为自动变量 */
    ...
}
```

<p>其中，a是形参，b、c是自动变量，对c赋初值3。执行完f函数后，自动释放a、b、c所占用的存储单元。</p>
<p>实际上关键字“auto”可以省略，auto不写则隐含确定为“自动存储类别”，它属于动态存储方式。程序中大多数变量都属于自动变量。前面介绍的函数中定义的变量都没有声明为auto，其实都隐含指定为自动变量。下面两种方式等价：</p>

```c
auto int b, c = 3;
```

```c
int b, c = 3;
```

### 8.9.3 用static声明局部变量

<p>有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，改变量已有值，并且是上次函数调用结束时的值。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。</p>
<p>例 8.17</p>

```c
include <stdio.h>

void main()
{
    int f(int);
    int a = 2, i;
    for(i = 0; i < 3; i++)
        printf("%d", f(a));
}


int f(int a)
{
    auto int b = 0;
    static int c = 3; /* f函数调用结束时此变量所占用的内存单元不释放并保留当前值 */
    b = b + 1;
    c = c + 1;
    return (a + b + c);
}
```

<p>静态局部变量的说明：</p>
<p>(1) 静态局部变量属于静态存储类别，在静态存储区分配存储单元。在程序整个运行期间都不释放。而自动变量(动态局部变量)属于动态存储类别，占动态存储区空间而不占静态存储区空间，函数调用结束后即释放。</p>
<p>(2) 对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。</p>
<p>(3) 如在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0(对数值型变量)或空字符(对字符型变量)。而对自动变量来说，如果不赋初值，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的存储单元中的值是不确定的。</p>
<p>(4) 虽然静态局部变量在函数调用结束后仍然存在，但其它函数是不能引用它的。</p>
<p>需要用静态局部变量的情况如下：</p>
<p>(1) 需要保留函数上一次调用结束时的值。如：求 n!。</p>
<p>例 8.18 输出1到5的阶乘值。</p>

```c
#include <stdio.h>

void main()
{
    int fac(int n);
    int i;
    for(i = 1; i <= 5; i++)
        printf("%d != %d\n", i, fac(i));
}

int fac(int n)
{
    static int f = 1; /* 编译时初始化，变量只被引用而不改变值 */
    f = f * n;
    return (f);
}
```
<p>(2) 如果初始化后，变量只被引用而不改变其值，则这时用静态静态局部变量比较方便，以免每次调用时重新赋值。</p>
<p>但是，用静态存储要多占内存(长期占用不释放，而不能像动态存储那样一个存储单元可供多个变量使用，节约内存)，并且降低了程序的可读性，当调用次数多时往往弄不清静态局部变量的当前值是什么。因此，非必要不使用静态局部变量。</p>

### 8.9.4 register变量

<p>一般情况下，变量(包括静态存储方式和动态存储方式)的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。</p>
<p>如果有一些变量使用频繁，则为存取变量的值要花费不少时间。为提高执行效率，C语言允许将局部变量的值放在CPU中的寄存器中，需要用时直接从寄存器取出参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量叫做寄存器变量，用关键字register作声明。</p>

```c
#include <stdio.h>


void main()
{
    long fac(long);
    long i, n;
    scanf("%ld", &n);
    for(i = 1; i <= n; i++)
        printf("%ld != %ld\n", i fac(i));
}

long fac(long n)
{
    register long i, f = 1; /* 定义寄存器变量，如果n的值大，能节约许多执行时间 */
    for(i = 1; i <= n; i++)
        f = f * i;
    return (f);
}
```

<p>说明：</p>
<p>(1) 只有局部自动变量和形式参数可以作为寄存器变量，其它(如全局变量)不行。在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束释放寄存器。此后调用另一个函数时又可以利用它来存放该函数的寄存器变量。</p>
<p>(2) 一个计算机系统中的寄存器数目是有限的，不能定义任意多个寄存器变量。不同的系统允许使用的寄存器个数是不同的，而且对register变量的处理方法也是不同的，有的系统对register变量当做自动变量处理，分配内存单元，并不真正把它们存放在寄存器中，有的系统只允许将int、char和指针型变量定义为寄存器变量。</p>
<p>(3) 局部静态变量不能定义为寄存器变量。不能写成</p>

```C
register static int a, b, c;
```

<p>不能把变量即放在静态存储区又放在寄存器中，二者只能居其一。对一个变量只能声明为一种存储类别。</p>
<p>当今的优化编系统能够识别使用频繁的变量，从而自动的将这些变量放在寄存器中，而不需要程序设计者指定。因此，用register声明变量是不必要的。编程人员只需要对它有一定了解即可。</p>

### 8.9.5 用extern声明外部变量

<p>外部变量是在函数的外部定义的全局变量，他的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为程序中各个函数所引用。编译时将外部变量分配在静态存储区。</p>
<p>有时需要用extern来声明外部变量，以扩展外部变量的作用域。</p>
<p><b>1，在一个文件内声明外部变量</b></p>
<p>如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件结束。如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字extern对改变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
<p>例 8.20</p>

```c
#include <stdio.h>

void main()
{
    int max(int, int);
    extern A, B;
    printf("%d\n", max(A, B));
}

int A = 13, B = -8;

int max(int x, int y)
{
    int z;
    z = z > y ? x : y;
    return (z);
}
```

<p>外部变量A、B定义在main函数之后，因此在main函数中不能引用外部变量A和B。在main函数中用extern对A和B进行“外部变量声明”，表示A和B是已经定义的外部变量(但定义位置在后面)。这样在main函数中就可以合法地使用全局变量A和B了。如果不作extern声明，编译时出错，系统不能识别A、B是已定义的外部变量。一般做法是外部变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。</p>
<p>用extern声明外部变量时，类型名也可以省略。以下两种方式等价：</p>

```c
extern int A, B;
```
```c
extern A, B;
```
<p><b>2，在多程序的文件中声明外部变量</b></p>
<p>一个C程序可以由一个或多个源程序文件组成。如果程序只是由一个源文件组成，使用外部变量的方法前面已经介绍。</p>
<p>如果程序由两个源程序文件组成，在两个文件中都要用到同一个外部变量Num，不能分别在两个文件中各自定义一个外部变量Num，否则在进行程序的连接时会出现“重复定义”的错误。正确的做法是：在任意一个文件中定义外部变量Num，而在另一个文件中用extern对Num作“外部变量声明”。即“extern Num;”。在编译和连接时，系统会由此知道Num是一个已在别处定义的外部变量，并将在另一个文件中定义的外部变量的作用域扩展到本文件，在本文件中可以合法地引用外部变量Num。</p>
<p>例 8.21 用extern将外部变量的作用域扩展到其它文件</p>
<p><b>文件file1.c中的内容为：</b></p>

```c
#include <stdio.h>

int A;

void main()
{
    int power(int);
    int b = 3, c, d, m;
    printf("enter the number a and its power m : \n");
    scanf("%d, %d", &A, &m);
    c = A * b;
    printf("%d * %d = %d\n", A, b, c);
    d = power(m);
    printf("%d * %d = %d\n", A, m, d);
}
```

<p><b>文件file2.c中的内容为：</b></p>

```c
extern A; /* 声明A为一个已经定义的外部变量，不必在为它分配内存 */

int power(int n)
{
    int i, y = 1;
    for(i = 1; i <= n; i++)
        y *= A;
    return (y);
}
```

<p>在编译时遇到extern时，先在本文件中找外部变量的定义，如果找到，就在本文件中扩展作用域；如果找不到，就在连接时从其它文件中找外部变量的定义。如果从其它文件中找到了，就将作用域扩展到本文件；如果再找不到，就按出错处理。</p>

### 8.9.6 用static声明外部变量

<p>有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其它文件引用。这时可以在定义外部变量时加一个static声明。</p>
<p>这种加上static声明、只能用于本文件的外部变量，称为“静态外部变量”。在程序设计中，经常是多人协作完成各个模块，各人可独立的在其设计的文件中使用相同的外部变量名而不互相干扰，只要在本文件中不想被其它文件引用的外部变量前面加上static。</p>
<p>注意：不要以为对外部变量加上static以后才是静态存储方式，不加static就是动态存储方式。两种形式的外部变量都是静态存储方式，只是作用范围不同而已，都是在编译时分配内存。</p>

### 8.9.7 关于变量的声明和定义

<p>第三章介绍了如何定义一个变量。本章介绍了如何对一个变量的存储类别作声明。定义和声明是两回事。</p>
<p>第三章介绍了函数一般由两部分组成：声明部分和执行语句。声明部分的作用是对有关的标识符(如变量、函数、结构体、共用体)的属性进行说明。对于函数，声明和定义的区别是明显的。函数的声明是函数的原型，而函数的定义是函数的本身。对被调用函数的声明是放在主调函数的声明部分中的，而函数的定义显然不在声明部分的范围内，它是一个独立的模块。</p>
<p>对变量而言，声明与定义的关系稍微复杂一些。在声明部分出现的变量有两种情况：一种是需要建立存储空间的(如：int a;)，另一种是不需要建立存储空间的(如：extern a;)。前者称为“定义性声明”(defining declaration)，或者简称定义(definition)。后者称为“引导性声明”(referencing declaration)。广义的说，声明包括定义，但并非所有的声明都是定义。对“int a;”而言，它既是声明，又是定义。而对“extern a;”而言，它是声明而不是定义。一般为了叙述方便，把建立存储空间的声明称定义，把不需要建立存储空间的声明称为声明。显然这里指的声明是狭义的，即非定义性声明。例如：</p>

```c
void main()
{
    extern A; /* 是声明，不是定义，声明A是一个已定义的外部变量 */
    ...
}

int A; /* 是定义，定义A为整型外部变量 */
```

<p>外部变量的声明和外部变量的含义是不同的。外部变量的定义只能有一次，它的位置在所有函数之外，而同一文件中的外部变量的声明可以有多次，它的位置可以在函数之内(哪个函数要用就在哪个函数中声明)，也可以在函数之外(在外部变量的定义点之前。系统根据外部变量的定义(而不是根据外部变量的声明)分配存储单元。对外部变量的初始化只能在“定义”时进行，而不能再“声明”中进行。所谓“声明”，其作用是声明该变量是一个已在后面(或在其它文件中)已定义的外部变量，仅仅是为了扩展该变量的作用范围而作的“声明”。extern 只用作声明，而不用于定义。</p>
<p>用 static 来声明一个变量的作用有二：</p>
<p>(1) 对局部变量用static声明，则使该变量在整个程序执行期间不释放，为其分配的空间始终在。</p>
<p>(2) 全局变量用static声明，则该变量的作用域只限于本文件模块(即被声明的文件中)。</p>
<p>注意：用auto、register、static声明变量时，是在定义变量的基础上加上这些关键字，不能单独使用。</p>

```c
int a; /* 先定义整型变量a */
static a; /* 再对变量a声明为静态变量，这样在编译时会被认定为“重新定义”，这种用法是不对的 */
```

### 8.9.8 存储类别小结

<p>综上可知，对一个数据的定义，需要指定两种属性：数据类型和存储类别，分别使用三个关键字</p>

```c
static int a; /* 静态内部整型变量或静态外部整型变量 */
auto char c; /* 自动变量，在函数内部定义 */
register int d; /* 寄存器变量，在函数内定义 */
```

<p>此外，可以用extern声明变量为已定义的外部变量，如：</p>

```c
extern b; /* 声明b是一个已经被定义的外部变量 */
```

<p>下面从不同角度做些归纳：</p>
<p>(1) 从作用域角度分，有局部变量和全局变量。</p>

<table>
<tr>
<td rowspan=6>按作用域角度分</td>
<td rowspan=4>局部变量</td>
<td>自动变量，即动态局部变量(离开函数，值就消失)</td>
</tr>
<tr>
<td>静态局部变量(离开函数，值仍保留)</td>
</tr>
<tr>
<td>寄存器变量(离开函数，值就消失)</td>
</tr>
<tr>
<td>(形式参数可以定义为自动变量或寄存器变量)</td>
</tr>
<tr>
<td rowspan=2>全局变量</td>
<td>静态外部变量(只限本文件引用)</td>
</tr>
<tr>
<td>外部变量(即非静态的外部变量，允许其它文件引用)</td>
</tr>
</table>

<p>(2) 从变量存在时间(生存期)来区分，有动态存储和静态存储两类。静态存储是程序整个运行时间都存在，而动态存储是在调用函数时临时分配单元。</p>

<table>
<tr>
<td rowspan=6>按变量存在时间分</td>
<td rowspan=3>动态存储</td>
<td>自动变量(本函数内有效)</td>
</tr>
<tr>
<td>寄存器变量(本函数内有效)</td>
</tr>
<tr>
<td>形式参数(本函数内有效)</td>
</tr>
<tr>
<td rowspan=3>静态存储</td>
<td>静态局部变量(函数内有效)</td>
</tr>
<tr>
<td>静态外部变量(本文件内有效)</td>
</tr>
<tr>
<td>外部变量(其它文件可引用)</td>
</tr>
</table>

<p>(3) 从变量值存放的位置来分：</p>

<table>
<tr>
<td rowspan=6>按变量值存放的位置分</td>
<td rowspan=3>内存中静态存储区</td>
<td>静态局部变量</td>
</tr>
<tr>
<td>静态外部变量(函数外部静态变量)</td>
</tr>
<tr>
<td>外部变量(可为其它文件引用)</td>
</tr>
<tr>
<td rowspan=2>内存中动态存储区</td>
<td>自动变量</td>
</tr>
<tr>
<td>形式参数</td>
</tr>
<tr>
<td>CPU中的寄存器</td>
<td>寄存器变量</td>
</tr>
</table>

<p>(4) 关于作用域和生存期的概念。对一个变量的性质可以从两个方面分析，一是变量的作用域，一是变量值存在时间的长短，即生存期。前者是从空间的角度，后者是从时间的角度。二者有联系但不是同一回事。</p>
<p>如果一个变量在某个文件或函数范围内是有效的，则称该文件或函数为该变量的作用域，在此作用域内可以引用该变量，所以又称变量在此作用域内“可见”，这种性质称为变量的可见性。如果一个变量值在某一时刻是存在的，则认为这一时刻属于该变量的“生存期”，或称该变量在此时刻“存在”。</p>

<p>表 8-2 各种类型变量的作用域和存在性</p>

<table>
<tr>
<td rowspan=2>变量存储类别</td>
<td colspan=2>函数内</td>
<td colspan=2>函数外</td>
</tr>
<tr>
<td>作用域</td>
<td>存在性</td>
<td>作用域</td>
<td>存在性</td>
</tr>
<tr>
<td>自动变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>寄存器变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>静态外部变量</td>
<td>O</td>
<td>O</td>
<td>O(只限本文件)</td>
<td>O</td>
</tr>
<tr>
<td>外部变量</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
</table>

<p>(5) static对局部变量和全局变量的作用不同。对局部变量来说，它使变量由动态存储方式变为静态存储方式。对全局变量来说，它使变量局部化(局部于本文件)，但仍为静态存储方式。从作用域角度看，凡有static声明的，其作用域都是局限的，或者是局限于本函数内(静态局部变量)，或者局限于本文件内(静态外部变量)。</p>

## 8.10 内部函数和外部函数

<p>函数本质上是全局的，因为一个函数要被另外的函数调用，但是也可以指定函数不能被其它文件调用。根据函数是否能被其它函数调用，将函数区分为内部函数和外部函数。</p>

### 8.10.1 内部函数

<p>如果一个函数只能被本文件中其它函数锁调用，就是内部函数。在定义内部函数时，在函数名和函数类型的前面加static，即：</p>

```c
static 类型标识符 函数名(形参表);
```

<p>例如：</p>

```c
static int fun(int a, int b);
```

<p>内部函数又叫静态函数，因为它是用static声明的。这样可以使函数的作用域只局限于所在文件，在不同文件中有同名的内部函数，互不干扰。这样可以让开发者不必担心所用函数是否会与其他文件中的函数同名，通常把只能由同一文件使用的函数和外部变量放在一个文件中，在它们前面都冠以static使之局部化，其它文件不能使用。</p>

### 8.10.2 外部函数

<p>(1) 在定义函数时，如果在函数的首部的最左端加关键字extern，表示此函数是外部函数，可供其它文件调用。</p>
<p>如函数首部可以写成：</p>

```c
extern int fun(int a, int b);
```

<p>这样，函数fun就可以为其它文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。本书前面锁用的函数都是外部函数。</p>
<p>(2) 在需要调用此函数的文件中，用extern对函数作声明，表示该函数是在其它文件中定义的外部函数。</p>
<p>例 8.22 有一个字符串，内有若干个字符，今输入一个字符，要求程序将字符串中该字符删去。用外部函数实现。</p>
<p><b>file1.c(文件1)</b></p>

```c
#include <stdio.h>

void main()
{
    extern void enter_string(char str[]); /* 可以写成 enter_string(char str[]); */
    extern void delete_string(char str[], char ch);
    extern void print_string(char str[]);
    /* 以上3行声明在本函数中将要调用的在其它文件中定义的三个函数 */
    
    char c;
    char str[80];
    enter_string(str);
    scanf("%c", &c);
    delete_string(str);
    print_string(str);
}

```

<p><b>file2.c(文件2)</b></p>

```c
#include <stdio.h>

void enter_string(char str[]) /* 定义外部函数 enter_string */
{
    gets(str); /* 向字符数组输入字符串 */
}
```

<p><b>file3.c(文件3)</b></p>

```c
#include <stdio.h>

void delete_string(char str[], char ch) /* 定义外部函数 delete_string */
{
    int i, j;
    for(i = j = 0; str[i] != '\0'; i++)
        if(str[i] != ch)
            str[j++] = str[i];
    
    str[j] = '\0';
}
```

<p><b>file4.c(文件4)</b></p>

```c
#include <stdio.h>

void print_string(char str[]) /* 定义外部函数 print_string */
{
    printf("%s\n", str);
}
```

<p>上例可知：使用extern声明就能够在一个文件中调用其它文件中定义的函数，或者说把该函数的作用域扩展到本文件。extern声明的形式就是在函数原型基础上加上关键字 extern(见本例main函数中的声明形式)。由于函数在本质上是外部的，在程序中经常要调用外部函数，为方便编程，C语言允许在声明函数时省写extern。例 8.21程序中main函数中对power函数的声明就没有用extern，但作用相同。一般都省写extern，例如例 8.22程序中main函数中的第一个函数声明。</p>
<p>这就是多次用过的函数原型。</p>
<p>由此可以进一步理解函数原型的作用。用函数原型能够把函数的作用域扩展到定义该函数的文件之外(不必使用extern)。只要在使用该函数的每一个文件中包含该函数的函数原型即可。函数原型通知编译系统：该函数在本文件中稍后定义，或在另一文件中定义。</p>
<p>利用函数原型扩展函数作用域最常见的例子是 #include 命令的应用，引入头文件。要求程序设计者在调用库函数时先从手册中查出所用的库函数的原型，并在程序中一一写出来是十分麻烦而困难的。为了减少程序设计者的困难，使用include命令引入相关库的头文件，里面包含了该库的所有函数原型和其它有关信息，就能在该文件中合法的调用该库的各个函数了。</p>

# 第九章 预处理命令

<p>ANSI C 标准规定可以在C源程序中加入一些“预处理命令”(preprocessor directives)，以改进程序设计环境，提高编程效率。这些预处理命令由ANSI C统一规定的，但是它不是C语言本身的组成部分，不能直接对它们进行编译(因为编译程序不能识别它们)。必须在对程序进行通常的编译(包括词法分析和语法分析、代码生成、优化等)之前，先对程序中这些特殊的命令进行“预处理”，即根据预处理命令对程序作相应的处理(例如，若程序中用#define命令定义了一个符号常量A，则在预处理时将程序中所有的A都置换为指定的字符串。若程序中用#include命令包含一个文件“stdio.h”，则在预处理时将stdio.h文件中的实际内容代替该命令)。</p>
<p>经过预处理后的程序不再包括预处理命令了，最后再由编译程序对预处理后的源程序进行通常的编译处理，得到可供执行的目标代码。现在使用的许多C编译系统都包括了预处理、编译和连接部分，在进行编译时一气呵成。因此不少用户误认为预处理命令是C语言的一部分，甚至以为它们是C语句，这是不对的。必须正确区别预处理命令和C语句，区别预处理和编译，才能正确使用预处理命令。C语言与其它高级语言的一个重要区别是可以使用预处理命令和具有预处理功能。</p>
<p>C提供的预处理功能主要有以下3种：</p>
<p>1. 宏定义</p>
<p>2. 文件包含</p>
<p>3. 条件编译</p>
<p>分别用宏定义命令、文件包含命令、条件编译命令来实现。为了与一般C语句相区别，这些命令以符号“#”开头。</p>

## 9.1 宏定义

### 9.1.1 不带参数的宏定义

<p>用一个指定的标识符(即名字)来代表一个字符串，它的一般形式为：</p>

```c
#define 标识符 字符串
```

<p>这就是已经介绍过的定义符号常量，例如：</p>

```c
#define PI 3.1415926
```

<p>它的作用是在本程序文件中用指定的标识符 PI 来代替“3.1415926”这个字符串，在编译预处理时，将程序中在该命令以后出现的所有的 PI 都用“3.1415926”代替。这种方法使用户能以一个简单的名字代替一个长的字符串，因此把这个标识符(名字)称为“宏名”，在预编译时将宏名替换成字符串的过程称为“宏展开”。#define 是宏定义命令。</p>
<p>例 9.1 使用不带参数的宏定义</p>

```c
#include <stdio.h>
#define PI 3.1415926

void main()
{
    float l, s, r, v;
    printf("input radius:");
    scanf("%f", &r);
    l = 2.0 * PI * r;
    s = PI * r * r;
    v = 4.0 / 3 * PI * r * r * r;
    printf("l = %10.4f\ns = %10.4f\nv = %10.4f\n", l, s, v);
}
```

<p>说明：</p>
<p>(1) 宏名一般习惯用大写字母表示，以便与变量名相区别，但这并非是规定，也可用小写字母。</p>
<p>(2) 使用宏名代替一个字符串，可以减少程序中重复书写某些字符串的工作量。例如，若不定义 PI 代表 3.1415926，则在程序中要多处出现 3.1415926，不仅麻烦，而且容易写错，用宏名代替，简单不易出错，因为记住一个宏名(它的名字往往用容易理解的单词表示)要比记住一个无规律的字符串容易，而且在读程序时能立即知道它的含义，当需要改变一个常量时，可以只改变 #define 命令行，一改全改。例如，定义数组大小，可以用：</p>

```c
#define array_size 1000
int array[array_size];
```

<p>如果需要改变数组大小，只需要修改宏 array_size 即可，提高了程序的通用性。</p>

<p>(3) 宏定义是用宏名代替一个字符串，也就是做简单的置换，不作正确性检查。例如在宏定义时写成：</p>

```c
#define PI 3.l415926
```

<p>即把数字 1 写成小写字母 l，预处理时也照样带入，不管是否符合用户原意，也不管含义是否有意义。预编译时不作任何语法检查。只有在编译已经被宏展开后的源程序时才会发现语法错误并报错。</p>

<p>(4) 宏定义不是C语句，不必在行末加分号。如果加了分号会连分号一起进行置换。如：</p>

```c
#define PI 3.1415926;
area = PI * r * r;
```

<p>经过宏展开后，该语句为：</p>

```c
area = 3.1415926; * r * r;
```

<p>显然出现了语法错误。</p>

<p>(5) </p>
<p>(6) </p>
<p>(7) </p>
<p>(8) </p>
<p>(9) </p>
<p></p>
<p></p>
<p></p>
<p></p>

### 9.1.2 带参数的宏定义

<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

## 9.2 "文件包含"处理

## 9.3 条件编译


# 第十章 指针

## 10.1 地址和指针的概念

## 10.2 变量的指针和指向变量的指针变量

### 10.2.1 定义一个指针变量

### 10.2.2 指针变量的引用

### 10.2.3 指针变量作为函数参数

## 10.3 数组与指针

### 10.3.1 指向数组元素的指针

### 10.3.2 通过指针引用数组元素

### 10.3.3 用数组名作函数参数

### 10.3.4 多维数组与指针

## 10.4 字符串与指针

### 10.4.1 字符串的表示形式

### 10.4.2 字符指针作函数参数

### 10.4.3 对使用字符指针变量和字符数组的讨论

## 10.5 指向函数的指针

### 10.5.1 用函数指针变量调用函数

### 10.5.2 用指向函数的指针作函数参数

## 10.6 返回指针值的函数

## 10.7 指针数组和指向指针的指针

### 10.7.1 指针数组的概念

### 10.7.2 指向指针的指针

### 10.7.3 指针数组作main函数的形参

## 10.8 有关指针的数据类型和指针运算的小结

### 10.8.1 有关指针的数据类型的小结

### 10.8.2 指针运算小结

### 10.8.3 void指针类型

# 第十一章 结构体与共用体

## 11.1 概述 

## 11.2 定义结构体类型变量的方法

## 11.3 结构体变量的引用

## 11.4 结构体变量的初始化

## 11.5 结构体数组

### 11.5.1 定义结构体数组

### 11.5.2 结构体数组的初始化

### 11.5.3 结构体数组应用举例

## 11.6 指向结构体类型数据的指针

### 11.6.1 指向结构体变量的指针

### 11.6.2 指向结构体数组的指针

### 11.6.1 用结构体变量和指向结构体的指针作函数参数

## 11.7 用指针处理链表

### 11.7.1 链表概述

### 11.7.2 简单链表

### 11.7.3 处理动态链表所需的函数

### 11.7.4 建立动态链表

### 11.7.5 输出链表

### 11.7.6 对链表的删除操作

### 11.7.7 对链表的插入操作

### 11.7.8 对链表的综合操作

## 11.8 共用体

### 11.8.1 共用体的概念

### 11.8.2 共用体变量的引用方式

### 11.8.3 共用体类型数据的特点

## 11.9 枚举类型

## 11.10 用 typedef定义类型

# 第十二章 位运算

# 第十三章 文件

# 第十四章 常见错误和程序调试
