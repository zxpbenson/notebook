# 目录

<table>
<caption>Overview</caption>
<tr><th>部分</th><th>大章节</th><th>小章节</th></tr>

<tr>
<td rowspan=14>第一部分</td>
<td rowspan=7>第1章 模式的简史和形而上学</td>
<td>1.1 模式是什么</td>
</tr>
<tr><td>1.2 软件模式的简史</td></tr>
<tr><td>1.3 模式的起源</td></tr>
<tr><td>1.4 与道家思想的关系</td></tr>
<tr><td>1.5 软件的永恒之道</td></tr>
<tr><td>1.6 模式的要素</td></tr>
<tr><td>1.7 本书讲解模式的格式</td></tr>

<tr>
<td rowspan=7>第2章 统一建模语言UML简介</td>
<td>2.1 建造世界贸易中心</td>
</tr>
<tr><td>2.2 什么是UML</td></tr>
<tr><td>2.3 UML包括什么</td></tr>
<tr><td>2.4 类图</td></tr>
<tr><td>2.5 时序图</td></tr>
<tr><td>2.6 状态图</td></tr>
<tr><td>2.7 UML及建模的工具</td></tr>

<tr>
<td rowspan=42>第二部分</td>
<td rowspan=3>第3章 软件的可维护性与可复用性</td>
<td>3.1 软件系统的可维护性</td>
</tr>
<tr><td>3.2 系统的可复用性</td></tr>
<tr><td>3.3 老子论“不武”</td></tr>

<tr>
<td rowspan=6>第4章 “开 - 闭”原则（OCP）</td>
<td>4.1 什么是“开 - 闭”原则</td>
</tr>
<tr><td>4.2 怎样做到“开 - 闭”原则</td></tr>
<tr><td>4.3 与其他设计原则的关系</td></tr>
<tr><td>4.4 策略模式对“开 - 闭”原则的支持</td></tr>
<tr><td>4.5 在其他设计模式中的体现</td></tr>
<tr><td>4.6 一个重构做法的讨论</td></tr>

<tr>
<td rowspan=3>第5章 专题：Java语言的接口</td>
<td>5.1 什么是接口</td>
</tr>
<tr><td>5.2 为什么使用接口</td></tr>
<tr><td>5.3 Java接口常见的用法</td></tr>

<tr>
<td rowspan=4>第6章 专题：抽象类</td>
<td>6.1 什么是抽象类</td>
</tr>
<tr><td>6.2 抽象类的用途</td></tr>
<tr><td>6.3 基于抽象类的模式和原则</td></tr>
<tr><td>6.4 什么时候才应当使用继承复用</td></tr>

<tr>
<td rowspan=5>第7章 里氏代换原则（LSP）</td>
<td>7.1 美猴王的智慧</td>
</tr>
<tr><td>7.2 什么是里氏代换原则</td></tr>
<tr><td>7.3 里氏代换原则在设计模式中的体现</td></tr>
<tr><td>7.4 墨子论“取譬”</td></tr>
<tr><td>7.5 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=8>第8章 依赖倒转原则（DIP）</td>
<td>8.1 为何而“倒转”</td>
</tr>
<tr><td>8.2 复用与可维护性的倒转</td></tr>
<tr><td>8.3 依赖倒转原则</td></tr>
<tr><td>8.4 怎样做到依赖倒转原则</td></tr>
<tr><td>8.5 Java对抽象类型的支持</td></tr>
<tr><td>8.6 一个例子：账号、账号的种类和账号的状态</td></tr>
<tr><td>8.7 墨子论“取周”</td></tr>
<tr><td>8.8 依赖倒转原则的优缺点</td></tr>

<tr>
<td rowspan=3>第9章 接口隔离原则（ISP）</td>
<td>9.1 什么是接口隔离原则</td>
</tr>
<tr><td>9.2 一个角色隔离原则的例子</td></tr>
<tr><td>9.3 定制服务的例子</td></tr>

<tr>
<td rowspan=3>第10章 合成/聚合复用原则（CARP）</td>
<td>10.1 合成和聚合的区别</td>
</tr>
<tr><td>10.2 复用的基本种类</td></tr>
<tr><td>10.3 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=7>第11章 迪米特法则（LoD）</td>
<td>11.1 迪米特法则的各种表述</td>
</tr>
<tr><td>11.2 狭义的迪米特法则</td></tr>
<tr><td>11.3 迪米特法则与设计模式</td></tr>
<tr><td>11.4 广义的迪米特法则</td></tr>
<tr><td>11.5 广义迪米特法则在类的设计上的体现</td></tr>
<tr><td>11.6 广义迪米特法则在代码层次上的实现</td></tr>
<tr><td>11.7 老子论“圣人之治”</td></tr>

<tr>
<td rowspan=72>第三部分</td>
<td rowspan=8>第12章 简单工厂（Simple Factory）模式</td>
<td>12.1 工厂模式的几种形态</td>
</tr>
<tr><td>12.2 简单工厂模式的引进</td></tr>
<tr><td>12.3 简单工厂模式的结构</td></tr>
<tr><td>12.4 简单工厂模式的实现</td></tr>
<tr><td>12.5 简单工厂模式与其他模式的关系</td></tr>
<tr><td>12.6 简单工厂模式的优点和缺点</td></tr>
<tr><td>12.7 简单工厂模式在Java中的应用</td></tr>
<tr><td>12.8 女娲抟(tuan2)土造人</td></tr>


<tr>
<td rowspan=8>第13章 工厂方法（Factory Method）模式</td>
<td>13.1 引言</td>
</tr>
<tr><td>13.2 工厂方法模式的结构</td></tr>
<tr><td>13.3 工厂方法模式在农场系统中的实现</td></tr>
<tr><td>13.4 关于工厂方法模式的实现</td></tr>
<tr><td>13.5 Java语言中工厂方法模式的例子</td></tr>
<tr><td>13.6 工厂方法模式与其他模式的关系</td></tr>
<tr><td>13.7 女娲举绳造人</td></tr>
<tr><td>13.8 其他的例子</td></tr>

<tr>
<td rowspan=10>第14章 抽象工厂（Abstract Factory）模式</td>
<td>14.1 引言</td>
</tr>
<tr><td>14.2 问题</td></tr>
<tr><td>14.3 抽象工厂模式的结构</td></tr>
<tr><td>14.4 在什么情形下应当使用抽象工厂模式</td></tr>
<tr><td>14.5 抽象工厂模式在农场系统中的实现</td></tr>
<tr><td>14.6 抽象工厂模式的另一个例子</td></tr>
<tr><td>14.7 “开 - 闭”原则</td></tr>
<tr><td>14.8 相关的模式与模式的实现</td></tr>
<tr><td>14.9 女娲造万物的故事</td></tr>
<tr><td>14.10 附录：JavaAWT的Peer架构与抽象工厂模式</td></tr>

<tr>
<td rowspan=10>第15章 单例（Singleton）模式</td>
<td>15.1 引言</td>
</tr>
<tr><td>15.2 单例模式的结构</td></tr>
<tr><td>15.3 在什么情况下使用单例模式</td></tr>
<tr><td>15.4 单例类的状态</td></tr>
<tr><td>15.5 一个实用的例子：属性管理器</td></tr>
<tr><td>15.6 Java语言中的单例模式</td></tr>
<tr><td>15.7 专题：不完全的单例类</td></tr>
<tr><td>15.8 相关模式</td></tr>
<tr><td>15.9 附录：双重检查成例的研究</td></tr>
<tr><td>15.10 给读者的一点建议</td></tr>

<tr>
<td rowspan=6>第16章 专题：单例模式与MX记录</td>
<td>16.1 问题与解决方案</td>
</tr>
<tr><td>16.2 目录服务与MX记录</td></tr>
<tr><td>16.3 JNDI架构介绍</td></tr>
<tr><td>16.4 如何使用JNDI编程</td></tr>
<tr><td>16.5 系统设计</td></tr>
<tr><td>16.6 讨论</td></tr>

<tr>
<td rowspan=3>第17章 专题：多例（Multiton）模式与多语言支持</td>
<td>17.1 引言</td>
</tr>
<tr><td>17.2 多例模式</td></tr>
<tr><td>17.3 多语言项目的设计</td></tr>

<tr>
<td rowspan=4>第18章 专题：序列键生成器与单例及多例模式</td>
<td>18.1 问题</td>
</tr>
<tr><td>18.2 将单例模式应用到系统设计中</td></tr>
<tr><td>18.3 想多例模式应用到系统设计中</td></tr>
<tr><td>18.4 讨论</td></tr>

<tr>
<td rowspan=9>第19章 建造（Builder）模式</td>
<td>19.1 引言</td>
</tr>
<tr><td>19.2 建造模式的结构</td></tr>
<tr><td>19.3 建造模式的活动序列</td></tr>
<tr><td>19.4 建造模式的实现</td></tr>
<tr><td>19.5 众神造人的神话故事</td></tr>
<tr><td>19.6 JavaMail中的建造模式</td></tr>
<tr><td>19.7 一个发送邮件的例子</td></tr>
<tr><td>19.8 在什么情况下使用建造模式</td></tr>
<tr><td>19.9 建造模式与其他模式的关系</td></tr>

<tr>
<td rowspan=9>第20章 原始模型（Prototype）模式</td>
<td>20.1 引言</td>
</tr>
<tr><td>20.2 变量、对象以及对象的引用</td></tr>
<tr><td>20.3 Java对象的复制</td></tr>
<tr><td>20.4 原始模型模式的结构</td></tr>
<tr><td>20.5 模式的实现：深复制和浅复制</td></tr>
<tr><td>20.6 孙大圣的身外身法术</td></tr>
<tr><td>20.7 在什么情况下使用原始模型模式</td></tr>
<tr><td>20.8 原始模型模式的优点和缺点</td></tr>
<tr><td>20.9 原始模型模式与其他模式的关系</td></tr>

<tr>
<td rowspan=5>第21章 专题：JavaBean的“冷藏”和“解冻”</td>
<td>21.1 什么是“冷藏”和“解冻”</td>
</tr>
<tr><td>21.2 什么可以“冷藏”</td></tr>
<tr><td>21.3 Beans.instantiate()方法</td></tr>
<tr><td>21.4 怎样在JSP中使用Beans.instantiate()方法</td></tr>
<tr><td>21.5 与装饰模式的关系</td></tr>

<tr>
<td rowspan=91>第四部分</td>
<td rowspan=10>第22章 适配器（Adapter）模式</td>
<td>22.1 引言</td>
</tr>
<tr><td>22.2 类的适配器模式的结构</td></tr>
<tr><td>22.3 类的适配器模式的效果</td></tr>
<tr><td>22.4 对象的适配器模式的结构</td></tr>
<tr><td>22.5 在什么情况下使用适配器模式</td></tr>
<tr><td>22.6 Iterator与Enumeration</td></tr>
<tr><td>22.7 利用适配器模式指方为圆</td></tr>
<tr><td>22.8 适配器模式在架构层次上的应用</td></tr>
<tr><td>22.9 关于模式实现的讨论</td></tr>
<tr><td>22.10 适配器模式与相关的模式</td></tr>

<tr>
<td rowspan=7>第23章 缺省适配（Default Adapter）模式</td>
<td>23.1 鲁智深的故事</td>
</tr>
<tr><td>23.2 WindowAdapter是缺省适配模式</td></tr>
<tr><td>23.3 模式的结构</td></tr>
<tr><td>23.4 在什么情况下使用本模式</td></tr>
<tr><td>23.5 模式的实现</td></tr>
<tr><td>23.6 J2SE中的缺省适配模式</td></tr>
<tr><td>23.7 一个例子</td></tr>

<tr>
<td rowspan=3>第24章 专题：XMLProperties与适配器模式</td>
<td>24.1 引言</td>
</tr>
<tr><td>24.2 SAX2浏览器</td></tr>
<tr><td>24.3 开始XMLProperties项目</td></tr>

<tr>
<td rowspan=10>第25章 合成（Composite）模式</td>
<td>25.1 对象的树结构</td>
</tr>
<tr><td>25.2 介绍合成模式</td></tr>
<tr><td>25.3 安全式和透明式的合成模式</td></tr>
<tr><td>25.4 安全式的合成模式的结构</td></tr>
<tr><td>25.5 透明式的合成模式的结构</td></tr>
<tr><td>25.6 合成模式的实现</td></tr>
<tr><td>25.7 道士的故事</td></tr>
<tr><td>25.8 一个绘图的例子</td></tr>
<tr><td>25.9 AWT库中的例子</td></tr>
<tr><td>25.10 合成模式与其他模式的关系</td></tr>

<tr>
<td rowspan=10>第26章 装饰（Decorator）模式</td>
<td>26.1 引言</td>
</tr>
<tr><td>26.2 装饰模式的结构</td></tr>
<tr><td>26.3 装饰模式应当在什么情况下使用</td></tr>
<tr><td>26.4 孙大圣的故事</td></tr>
<tr><td>26.5 使用装饰模式的优点和缺点</td></tr>
<tr><td>26.6 模式实现的讨论</td></tr>
<tr><td>26.7 装饰模式与其他模式的关系</td></tr>
<tr><td>26.8 实例：GrepReader</td></tr>
<tr><td>26.9 一个例子：发票系统</td></tr>
<tr><td>26.10 附录：关于适配器模式与装饰模式的对话</td></tr>

<tr>
<td rowspan=6>第27章 专题：设计模式在Java I/O库中的应用</td>
<td>27.1 引言</td>
</tr>
<tr><td>27.2 Java I/O库的设计原则</td></tr>
<tr><td>27.3 装饰模式的应用</td></tr>
<tr><td>27.4 半透明的装饰模式</td></tr>
<tr><td>27.5 适配器模式的应用</td></tr>
<tr><td>27.6 从byte流到char流的适配</td></tr>

<tr>
<td rowspan=9>第28章 代理（Proxy）模式</td>
<td>28.1 引言</td>
</tr>
<tr><td>28.2 代理的种类</td></tr>
<tr><td>28.3 代理模式的结构</td></tr>
<tr><td>28.4 代理模式的时序</td></tr>
<tr><td>28.5 Java 2.0对代理模式的支持</td></tr>
<tr><td>28.6 高老庄悟空降八戒</td></tr>
<tr><td>28.7 代理模式的优点和缺点</td></tr>
<tr><td>28.8 代理模式的实现</td></tr>
<tr><td>28.9 代理模式与其他模式的关系</td></tr>

<tr>
<td rowspan=4>第29章 专题：智能引用代理</td>
<td>29.1 问题</td>
</tr>
<tr><td>29.2 系统设计</td></tr>
<tr><td>29.3 系统的时序</td></tr>
<tr><td>29.4 系统的源代码</td></tr>

<tr>
<td rowspan=5>第30章 专题：虚拟代理的例子</td>
<td>30.1 问题</td>
</tr>
<tr><td>30.2 系统的要求</td></tr>
<tr><td>30.3 系统的设计</td></tr>
<tr><td>30.4 系统的时序</td></tr>
<tr><td>30.5 系统的源代码</td></tr>

<tr>
<td rowspan=10>第31章 享元模式（Flyweight Pattern）</td>
<td>31.1 引言</td>
</tr>
<tr><td>31.2 单纯享元模式的结构</td></tr>
<tr><td>31.3 复合享元模式的结构</td></tr>
<tr><td>31.4 模式的实现</td></tr>
<tr><td>31.5 一个咖啡摊的例子</td></tr>
<tr><td>31.6 咖啡屋的例子</td></tr>
<tr><td>31.7 享元模式应当在什么情况下使用</td></tr>
<tr><td>31.8 从代码重构的角度看享元模式</td></tr>
<tr><td>31.9 享元模式的优点和缺点</td></tr>
<tr><td>31.10 相关的模式</td></tr>

<tr>
<td rowspan=8>第32章 门面（Facade）模式</td>
<td>32.1 引言</td>
</tr>
<tr><td>32.2 门面模式的结构</td></tr>
<tr><td>32.3 门面模式的实现</td></tr>
<tr><td>32.4 在什么情况下使用门面模式</td></tr>
<tr><td>32.5 迪米特法则（LoD）</td></tr>
<tr><td>32.6 一个例子</td></tr>
<tr><td>32.7 使用门面模式的设计</td></tr>
<tr><td>32.8 Session门面模式</td></tr>

<tr>
<td rowspan=9>第33章 桥梁（Bridge）模式</td>
<td>33.1 引言</td>
</tr>
<tr><td>33.2 桥梁模式的结构</td></tr>
<tr><td>33.3 Java语言中的Peer架构</td></tr>
<tr><td>33.4 驱动器和JDBC驱动器</td></tr>
<tr><td>33.5 从重构的角度考察</td></tr>
<tr><td>33.6 桥梁模式和其他模式的关系</td></tr>
<tr><td>33.7 八戒“转世投胎”的故事</td></tr>
<tr><td>33.8 关于桥梁模式的实现</td></tr>
<tr><td>33.9 在什么情况下应当使用桥梁模式</td></tr>

<tr>
<td rowspan=143>第五部分</td>
<td rowspan=6>第34章 不变（Immutable）模式</td>
<td>34.1 引言</td>
</tr>
<tr><td>34.2 不变模式的结构和实现</td></tr>
<tr><td>34.3 不变模式在Java语言中的应用</td></tr>
<tr><td>34.4 不变模式的优点和缺点</td></tr>
<tr><td>34.5 不变模式与享元模式的关系</td></tr>
<tr><td>34.6 一个例子：复数类</td></tr>

<tr>
<td rowspan=10>第35章 策略（Strategy）模式</td>
<td>35.1 引言</td>
</tr>
<tr><td>35.2 模式的实现</td></tr>
<tr><td>35.3 Java语言内部的例子</td></tr>
<tr><td>35.4 排序策略系统</td></tr>
<tr><td>35.5 一个例子：图书折扣的计算</td></tr>
<tr><td>35.6 在什么情况下应当使用策略模式</td></tr>
<tr><td>35.7 策略模式的优点和缺点</td></tr>
<tr><td>35.8 策略模式与其他模式的关系</td></tr>
<tr><td>35.9 设计原则的讨论</td></tr>
<tr><td>35.10 诸葛亮的锦囊妙计</td></tr>

<tr>
<td rowspan=10>第36章 模板方法（Template Method）模式</td>
<td>36.1 引言</td>
</tr>
<tr><td>36.2 模板方法模式的结构</td></tr>
<tr><td>36.3 “好莱坞原则”</td></tr>
<tr><td>36.4 一个例子</td></tr>
<tr><td>36.5 继承作为复用的工具</td></tr>
<tr><td>36.6 Java语言里面使用过的模板方法模式</td></tr>
<tr><td>36.7 模板方法模式中的方法</td></tr>
<tr><td>36.8 模板方法模式在代码重构中的应用</td></tr>
<tr><td>36.9 重构的原则</td></tr>
<tr><td>36.10 西天取经的八十一难</td></tr>

<tr>
<td rowspan=3>第37章 专题：Servlet技术中的模式</td>
<td>37.1 Servlet技术介绍</td>
</tr>
<tr><td>37.2 模板方法模式的使用</td></tr>
<tr><td>37.3 观察者模式的应用</td></tr>

<tr>
<td rowspan=7>第38章 观察者（Observer）模式</td>
<td>38.1 引言</td>
</tr>
<tr><td>38.2 观察者模式的结构</td></tr>
<tr><td>38.3 另一种实现方案</td></tr>
<tr><td>38.4 Java语言提供的对观察者模式的支持</td></tr>
<tr><td>38.5 菩萨的守瓶龟</td></tr>
<tr><td>38.6 Java中的DEM事件机制</td></tr>
<tr><td>38.7 观察者模式与其他模式的关系</td></tr>

<tr>
<td rowspan=2>第39章 专题：观察者模式与AWT中的事件处理</td>
<td>39.1 引言</td>
</tr>
<tr><td>39.2 DEM的结构</td></tr>

<tr>
<td rowspan=7>第40章 专题：观察者热模式与SAX2浏览器</td>
<td>40.1 引言</td>
</tr>
<tr><td>40.2 SAX2是怎么工作的</td></tr>
<tr><td>40.3 ContentHandler接口</td></tr>
<tr><td>40.4 怎样实现ContentHandler接口</td></tr>
<tr><td>40.5 怎样使用ContentHandler</td></tr>
<tr><td>40.6 缺省适配模式与DefaultHandler</td></tr>
<tr><td>40.7 简单工厂模式的应用</td></tr>

<tr>
<td rowspan=5>第41章 专题：观察者模式与Swing定时器</td>
<td>41.1 为什么需要定时器</td>
</tr>
<tr><td>41.2 Utility定时器与Swing定时器的区别</td></tr>
<tr><td>41.3 使用Swing定时器的方法</td></tr>
<tr><td>41.4 观察者模式的应用</td></tr>
<tr><td>41.5 单例模式的应用</td></tr>

<tr>
<td rowspan=6>第42章 专题：MVC模式与用户输入数据检查</td>
<td>42.1 什么是MVC模式</td>
</tr>
<tr><td>42.2 MVC是架构模式</td></tr>
<tr><td>42.3 MVC模式在J2EE技术中的应用</td></tr>
<tr><td>42.4 从代码重构的角度查看</td></tr>
<tr><td>42.5 用户输入检查与MVC模式</td></tr>
<tr><td>42.6 SQL注射</td></tr>

<tr>
<td rowspan=6>第43章 迭代子（Iterator）模式</td>
<td>43.1 引言</td>
</tr>
<tr><td>43.2 迭代子模式的结构</td></tr>
<tr><td>43.3 迭代子模式的实现</td></tr>
<tr><td>43.4 迭代子模式的优点和缺点</td></tr>
<tr><td>43.5 一个例子</td></tr>
<tr><td>43.6 迭代子模式与其他模式的关系</td></tr>


<tr>
<td rowspan=6>第44章 专题：Java对迭代子模式的支持</td>
<td>44.1 Java聚集</td>
</tr>
<tr><td>44.2 Java聚集中的迭代子</td></tr>
<tr><td>44.3 java.util.Iterator接口</td></tr>
<tr><td>44.4 Java迭代子接口ListIterator</td></tr>
<tr><td>44.5 Enumeration与Iterator</td></tr>
<tr><td>44.6 其他相关模式</td></tr>

<tr>
<td rowspan=10>第45章 责任链（Chain of Responsibility）模式</td>
<td>45.1 从击鼓传花谈起</td>
</tr>
<tr><td>45.2 责任链模式的结构</td></tr>
<tr><td>45.3 纯的与不纯的责任链模式</td></tr>
<tr><td>45.4 Java 1.0版本的AWT事件处理机制</td></tr>
<tr><td>45.5 『红楼梦』中击鼓传花的故事</td></tr>
<tr><td>45.6 Java系统的解</td></tr>
<tr><td>45.7 责任链模式的实现</td></tr>
<tr><td>45.8 对象的树结构</td></tr>
<tr><td>45.9 DHTML中的事件处理</td></tr>
<tr><td>45.10 责任链模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第46章 专题：定时器与击鼓传花</td>
<td>46.1 线程</td>
</tr>
<tr><td>46.2 定时器</td></tr>
<tr><td>46.3 击鼓传花</td></tr>

<tr>
<td rowspan=11>第47章 命令（Command）模式</td>
<td>47.1 引言</td>
</tr>
<tr><td>47.2 命令模式的结构</td></tr>
<tr><td>47.3 玉帝传美猴王上天</td></tr>
<tr><td>47.4 Java语言内的例子：AWT的事件处理</td></tr>
<tr><td>47.5 一个例子：创世纪系统</td></tr>
<tr><td>47.6 一个例子：AudioPlayer系统</td></tr>
<tr><td>47.7 增加宏命令功能</td></tr>
<tr><td>47.8 模式的实现</td></tr>
<tr><td>47.9 在什么情况下应当使用命令模式</td></tr>
<tr><td>47.10 使用命令模式的优点和缺点</td></tr>
<tr><td>47.10 命令模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第48章 专题：Swing库中的命令撤销和恢复</td>
<td>48.1 在视窗系统中使用命令模式</td>
</tr>
<tr><td>48.2 Swing的基本撤销功能</td></tr>
<tr><td>48.3 一休论禅的文字框</td></tr>

<tr>
<td rowspan=12>第49章 备忘录（Memento）模式</td>
<td>49.1 备忘录模式的结构</td>
</tr>
<tr><td>49.2 备忘录模式的白箱实现</td></tr>
<tr><td>49.3 双重接口及其在Java语言中的实现</td></tr>
<tr><td>49.4 备忘录模式的黑箱实现</td></tr>
<tr><td>49.5 责任人角色的增强</td></tr>
<tr><td>49.6 备忘录模式与多重检查点</td></tr>
<tr><td>49.7 “自述历史”模式</td></tr>
<tr><td>49.8 “假如”协议模式</td></tr>
<tr><td>49.9 备忘录模式与其他模式的关系</td></tr>
<tr><td>49.10 备忘录模式的应用</td></tr>
<tr><td>49.11 使用备忘录模式的优点和缺点</td></tr>
<tr><td>49.12 观世音甘泉活树的故事</td></tr>

<tr>
<td rowspan=10>第50章 状态（State）模式</td>
<td>50.1 引言</td>
</tr>
<tr><td>50.2 状态模式的结构</td></tr>
<tr><td>50.3 曾侯乙编钟的描述</td></tr>
<tr><td>50.4 状态模式的效果</td></tr>
<tr><td>50.5 在什么情况下使用状态模式</td></tr>
<tr><td>50.6 关于模式实现的讨论</td></tr>
<tr><td>50.7 一个状态模式的应用例子：TCP</td></tr>
<tr><td>50.8 状态模式在绘图软件中的应用</td></tr>
<tr><td>50.9 用户登录子系统</td></tr>
<tr><td>50.10 状态模式与策略模式的区别</td></tr>

<tr>
<td rowspan=3>第51章 专题：崂山道士与状态模式</td>
<td>51.1 有状态的墙</td>
</tr>
<tr><td>51.2 异常逻辑</td></tr>
<tr><td>51.3 从代码重构的角度考察</td></tr>

<tr>
<td rowspan=3>第52章 专题：单分派和多分派</td>
<td>52.1 分派的概念</td>
</tr>
<tr><td>52.2 双重分派</td></tr>
<tr><td>52.3 未来的Java语言</td></tr>

<tr>
<td rowspan=9>第53章 访问者（Visitor）模式</td>
<td>53.1 引言</td>
</tr>
<tr><td>53.2 访问者模式的结构</td></tr>
<tr><td>53.3 系统的时序图</td></tr>
<tr><td>53.4 在什么情况下应当使用访问者模式</td></tr>
<tr><td>53.5 使用访问者模式的优点和缺点</td></tr>
<tr><td>53.6 访问者模式的实现</td></tr>
<tr><td>53.7 电脑专卖系统：问题与对象</td></tr>
<tr><td>53.8 电脑专卖系统的访问者模式设计</td></tr>
<tr><td>53.9 与访问者模式有关的模式</td></tr>

<tr>
<td rowspan=4>第54章 解释器（Interpreter）模式</td>
<td>54.1 引言</td>
</tr>
<tr><td>54.2 解释器模式的结构</td></tr>
<tr><td>54.3 一个示意性的实现</td></tr>
<tr><td>54.4 有关模式</td></tr>

<tr>
<td rowspan=7>第55章 调停者（Mediator）模式</td>
<td>55.1 引言</td>
</tr>
<tr><td>55.2 调停者模式的结构</td></tr>
<tr><td>55.3 调停者模式的实现</td></tr>
<tr><td>55.4 迪米特法则（LoD）</td></tr>
<tr><td>55.5 调停者模式的优点和缺点</td></tr>
<tr><td>55.6 调停者模式的使用条件</td></tr>
<tr><td>55.7 与调停者模式有关的模式</td></tr>

<tr>
<td rowspan=5>附录</td>
<td rowspan=3>附录A 设计模式一览表</td>
<td>A.1 创建模式</td>
</tr>
<tr><td>A.2 结构模式</td></tr>
<tr><td>A.3 行为模式</td></tr>

<tr>
<td rowspan=1>附录B UML图标及Java实现</td>
<td>一览表</td>
</tr>

<tr>
<td colspan=2>附录C 中英术语对照表</td>
</tr>
</table>

# 第一部分

# 第二部分

# 第三部分 创建模式

>创建模式（Createional Pattern）是对类的实例化过程的抽象化。
>一些系统在创建对象时，需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。
>创建模式描述了怎样构造和封装这些动态的决定。

<table>
<caption>创建模式分两类</caption>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
<tr>
<td>类的创建模式</td>
<td>
使用继承关系把类的创建延迟到子类<br>
从而封装了客户端将得到哪些具体类的信息<br>
并且隐藏了这些类的实例是如何被创建和放在一起的
</td>
</tr>
<tr>
<td>对象的创建模式</td>
<td>
把对象的创建过程动态的委派给另一个对象<br>
从而动态的决定客户端将得到哪些具体类的实例<br>
以及这些类的实例是如何被创建和组合在一起的<br>
</td>
</tr>
</table>

下面将介绍以下创建模式及专题：

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 单例模式（专题：单例模式与MX记录）
* 多例模式（专题：序列键生成器与单例及多例模式）
* 建造模式
* 原始模型模式（专题：JavaBean的“冷藏”和“解冻”）

## 第12章 简单工厂

>简单工厂模式是类的创建模式，是由一个工厂对象决定创建出哪一种产品类的示例

### 12.1 工厂模式的几种形态

* 简单工厂(Simple Factory)模式又叫静态工厂方法模式(Static Factory Method Pattern)
* 工厂方法(Factory Method)模式又叫多态工厂(Polymorphic Factory)模式或者虚拟构造子(Virtual Constructor)模式
* 抽象工厂(Abstract Factory)模式又叫工具箱(Kit or Toolkit)模式


# 第四部分

# 第五部分
