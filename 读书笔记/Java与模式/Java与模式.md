# 目录

<table>
<caption>Overview</caption>
<tr><th>部分</th><th>大章节</th><th>小章节</th></tr>

<tr>
<td rowspan=14>第一部分</td>
<td rowspan=7>第1章 模式的简史和形而上学</td>
<td>1.1 模式是什么</td>
</tr>
<tr><td>1.2 软件模式的简史</td></tr>
<tr><td>1.3 模式的起源</td></tr>
<tr><td>1.4 与道家思想的关系</td></tr>
<tr><td>1.5 软件的永恒之道</td></tr>
<tr><td>1.6 模式的要素</td></tr>
<tr><td>1.7 本书讲解模式的格式</td></tr>

<tr>
<td rowspan=7>第2章 统一建模语言UML简介</td>
<td>2.1 建造世界贸易中心</td>
</tr>
<tr><td>2.2 什么是UML</td></tr>
<tr><td>2.3 UML包括什么</td></tr>
<tr><td>2.4 类图</td></tr>
<tr><td>2.5 时序图</td></tr>
<tr><td>2.6 状态图</td></tr>
<tr><td>2.7 UML及建模的工具</td></tr>

<tr>
<td rowspan=42>第二部分</td>
<td rowspan=3>第3章 软件的可维护性与可复用性</td>
<td>3.1 软件系统的可维护性</td>
</tr>
<tr><td>3.2 系统的可复用性</td></tr>
<tr><td>3.3 老子论“不武”</td></tr>

<tr>
<td rowspan=6>第4章 “开 - 闭”原则（OCP）</td>
<td>4.1 什么是“开 - 闭”原则</td>
</tr>
<tr><td>4.2 怎样做到“开 - 闭”原则</td></tr>
<tr><td>4.3 与其他设计原则的关系</td></tr>
<tr><td>4.4 策略模式对“开 - 闭”原则的支持</td></tr>
<tr><td>4.5 在其他设计模式中的体现</td></tr>
<tr><td>4.6 一个重构做法的讨论</td></tr>

<tr>
<td rowspan=3>第5章 专题：Java语言的接口</td>
<td>5.1 什么是接口</td>
</tr>
<tr><td>5.2 为什么使用接口</td></tr>
<tr><td>5.3 Java接口常见的用法</td></tr>

<tr>
<td rowspan=4>第6章 专题：抽象类</td>
<td>6.1 什么是抽象类</td>
</tr>
<tr><td>6.2 抽象类的用途</td></tr>
<tr><td>6.3 基于抽象类的模式和原则</td></tr>
<tr><td>6.4 什么时候才应当使用继承复用</td></tr>

<tr>
<td rowspan=5>第7章 里氏代换原则（LSP）</td>
<td>7.1 美猴王的智慧</td>
</tr>
<tr><td>7.2 什么是里氏代换原则</td></tr>
<tr><td>7.3 里氏代换原则在设计模式中的体现</td></tr>
<tr><td>7.4 墨子论“取譬”</td></tr>
<tr><td>7.5 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=8>第8章 依赖倒转原则（DIP）</td>
<td>8.1 为何而“倒转”</td>
</tr>
<tr><td>8.2 复用与可维护性的倒转</td></tr>
<tr><td>8.3 依赖倒转原则</td></tr>
<tr><td>8.4 怎样做到依赖倒转原则</td></tr>
<tr><td>8.5 Java对抽象类型的支持</td></tr>
<tr><td>8.6 一个例子：账号、账号的种类和账号的状态</td></tr>
<tr><td>8.7 墨子论“取周”</td></tr>
<tr><td>8.8 依赖倒转原则的优缺点</td></tr>

<tr>
<td rowspan=3>第9章 接口隔离原则（ISP）</td>
<td>9.1 什么是接口隔离原则</td>
</tr>
<tr><td>9.2 一个角色隔离原则的例子</td></tr>
<tr><td>9.3 定制服务的例子</td></tr>

<tr>
<td rowspan=3>第10章 合成/聚合复用原则（CARP）</td>
<td>10.1 合成和聚合的区别</td>
</tr>
<tr><td>10.2 复用的基本种类</td></tr>
<tr><td>10.3 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=7>第11章 迪米特法则（LoD）</td>
<td>11.1 迪米特法则的各种表述</td>
</tr>
<tr><td>11.2 狭义的迪米特法则</td></tr>
<tr><td>11.3 迪米特法则与设计模式</td></tr>
<tr><td>11.4 广义的迪米特法则</td></tr>
<tr><td>11.5 广义迪米特法则在类的设计上的体现</td></tr>
<tr><td>11.6 广义迪米特法则在代码层次上的实现</td></tr>
<tr><td>11.7 老子论“圣人之治”</td></tr>

<tr>
<td rowspan=72>第三部分</td>
<td rowspan=8>第12章 简单工厂（Simple Factory）模式</td>
<td>12.1 工厂模式的几种形态</td>
</tr>
<tr><td>12.2 简单工厂模式的引进</td></tr>
<tr><td>12.3 简单工厂模式的结构</td></tr>
<tr><td>12.4 简单工厂模式的实现</td></tr>
<tr><td>12.5 简单工厂模式与其他模式的关系</td></tr>
<tr><td>12.6 简单工厂模式的优点和缺点</td></tr>
<tr><td>12.7 简单工厂模式在Java中的应用</td></tr>
<tr><td>12.8 女娲抟(tuan2)土造人</td></tr>


<tr>
<td rowspan=8>第13章 工厂方法（Factory Method）模式</td>
<td>13.1 引言</td>
</tr>
<tr><td>13.2 工厂方法模式的结构</td></tr>
<tr><td>13.3 工厂方法模式在农场系统中的实现</td></tr>
<tr><td>13.4 关于工厂方法模式的实现</td></tr>
<tr><td>13.5 Java语言中工厂方法模式的例子</td></tr>
<tr><td>13.6 工厂方法模式与其他模式的关系</td></tr>
<tr><td>13.7 女娲举绳造人</td></tr>
<tr><td>13.8 其他的例子</td></tr>

<tr>
<td rowspan=10>第14章 抽象工厂（Abstract Factory）模式</td>
<td>14.1 引言</td>
</tr>
<tr><td>14.2 问题</td></tr>
<tr><td>14.3 抽象工厂模式的结构</td></tr>
<tr><td>14.4 在什么情形下应当使用抽象工厂模式</td></tr>
<tr><td>14.5 抽象工厂模式在农场系统中的实现</td></tr>
<tr><td>14.6 抽象工厂模式的另一个例子</td></tr>
<tr><td>14.7 “开 - 闭”原则</td></tr>
<tr><td>14.8 相关的模式与模式的实现</td></tr>
<tr><td>14.9 女娲造万物的故事</td></tr>
<tr><td>14.10 附录：JavaAWT的Peer架构与抽象工厂模式</td></tr>

<tr>
<td rowspan=10>第15章 单例（Singleton）模式</td>
<td>15.1 引言</td>
</tr>
<tr><td>15.2 单例模式的结构</td></tr>
<tr><td>15.3 在什么情况下使用单例模式</td></tr>
<tr><td>15.4 单例类的状态</td></tr>
<tr><td>15.5 一个实用的例子：属性管理器</td></tr>
<tr><td>15.6 Java语言中的单例模式</td></tr>
<tr><td>15.7 专题：不完全的单例类</td></tr>
<tr><td>15.8 相关模式</td></tr>
<tr><td>15.9 附录：双重检查成例的研究</td></tr>
<tr><td>15.10 给读者的一点建议</td></tr>

<tr>
<td rowspan=6>第16章 专题：单例模式与MX记录</td>
<td>16.1 问题与解决方案</td>
</tr>
<tr><td>16.2 目录服务与MX记录</td></tr>
<tr><td>16.3 JNDI架构介绍</td></tr>
<tr><td>16.4 如何使用JNDI编程</td></tr>
<tr><td>16.5 系统设计</td></tr>
<tr><td>16.6 讨论</td></tr>

<tr>
<td rowspan=3>第17章 专题：多例（Multiton）模式与多语言支持</td>
<td>17.1 引言</td>
</tr>
<tr><td>17.2 多例模式</td></tr>
<tr><td>17.3 多语言项目的设计</td></tr>

<tr>
<td rowspan=4>第18章 专题：序列键生成器与单例及多例模式</td>
<td>18.1 问题</td>
</tr>
<tr><td>18.2 将单例模式应用到系统设计中</td></tr>
<tr><td>18.3 想多例模式应用到系统设计中</td></tr>
<tr><td>18.4 讨论</td></tr>

<tr>
<td rowspan=9>第19章 建造（Builder）模式</td>
<td>19.1 引言</td>
</tr>
<tr><td>19.2 建造模式的结构</td></tr>
<tr><td>19.3 建造模式的活动序列</td></tr>
<tr><td>19.4 建造模式的实现</td></tr>
<tr><td>19.5 众神造人的神话故事</td></tr>
<tr><td>19.6 JavaMail中的建造模式</td></tr>
<tr><td>19.7 一个发送邮件的例子</td></tr>
<tr><td>19.8 在什么情况下使用建造模式</td></tr>
<tr><td>19.9 建造模式与其他模式的关系</td></tr>

<tr>
<td rowspan=9>第20章 原始模型（Prototype）模式</td>
<td>20.1 引言</td>
</tr>
<tr><td>20.2 变量、对象以及对象的引用</td></tr>
<tr><td>20.3 Java对象的复制</td></tr>
<tr><td>20.4 原始模型模式的结构</td></tr>
<tr><td>20.5 模式的实现：深复制和浅复制</td></tr>
<tr><td>20.6 孙大圣的身外身法术</td></tr>
<tr><td>20.7 在什么情况下使用原始模型模式</td></tr>
<tr><td>20.8 原始模型模式的优点和缺点</td></tr>
<tr><td>20.9 原始模型模式与其他模式的关系</td></tr>

<tr>
<td rowspan=5>第21章 专题：JavaBean的“冷藏”和“解冻”</td>
<td>21.1 什么是“冷藏”和“解冻”</td>
</tr>
<tr><td>21.2 什么可以“冷藏”</td></tr>
<tr><td>21.3 Beans.instantiate()方法</td></tr>
<tr><td>21.4 怎样在JSP中使用Beans.instantiate()方法</td></tr>
<tr><td>21.5 与装饰模式的关系</td></tr>

<tr>
<td rowspan=91>第四部分</td>
<td rowspan=10>第22章 适配器（Adapter）模式</td>
<td>22.1 引言</td>
</tr>
<tr><td>22.2 类的适配器模式的结构</td></tr>
<tr><td>22.3 类的适配器模式的效果</td></tr>
<tr><td>22.4 对象的适配器模式的结构</td></tr>
<tr><td>22.5 在什么情况下使用适配器模式</td></tr>
<tr><td>22.6 Iterator与Enumeration</td></tr>
<tr><td>22.7 利用适配器模式指方为圆</td></tr>
<tr><td>22.8 适配器模式在架构层次上的应用</td></tr>
<tr><td>22.9 关于模式实现的讨论</td></tr>
<tr><td>22.10 适配器模式与相关的模式</td></tr>

<tr>
<td rowspan=7>第23章 缺省适配（Default Adapter）模式</td>
<td>23.1 鲁智深的故事</td>
</tr>
<tr><td>23.2 WindowAdapter是缺省适配模式</td></tr>
<tr><td>23.3 模式的结构</td></tr>
<tr><td>23.4 在什么情况下使用本模式</td></tr>
<tr><td>23.5 模式的实现</td></tr>
<tr><td>23.6 J2SE中的缺省适配模式</td></tr>
<tr><td>23.7 一个例子</td></tr>

<tr>
<td rowspan=3>第24章 专题：XMLProperties与适配器模式</td>
<td>24.1 引言</td>
</tr>
<tr><td>24.2 SAX2浏览器</td></tr>
<tr><td>24.3 开始XMLProperties项目</td></tr>

<tr>
<td rowspan=10>第25章 合成（Composite）模式</td>
<td>25.1 对象的树结构</td>
</tr>
<tr><td>25.2 介绍合成模式</td></tr>
<tr><td>25.3 安全式和透明式的合成模式</td></tr>
<tr><td>25.4 安全式的合成模式的结构</td></tr>
<tr><td>25.5 透明式的合成模式的结构</td></tr>
<tr><td>25.6 合成模式的实现</td></tr>
<tr><td>25.7 道士的故事</td></tr>
<tr><td>25.8 一个绘图的例子</td></tr>
<tr><td>25.9 AWT库中的例子</td></tr>
<tr><td>25.10 合成模式与其他模式的关系</td></tr>

<tr>
<td rowspan=10>第26章 装饰（Decorator）模式</td>
<td>26.1 引言</td>
</tr>
<tr><td>26.2 装饰模式的结构</td></tr>
<tr><td>26.3 装饰模式应当在什么情况下使用</td></tr>
<tr><td>26.4 孙大圣的故事</td></tr>
<tr><td>26.5 使用装饰模式的优点和缺点</td></tr>
<tr><td>26.6 模式实现的讨论</td></tr>
<tr><td>26.7 装饰模式与其他模式的关系</td></tr>
<tr><td>26.8 实例：GrepReader</td></tr>
<tr><td>26.9 一个例子：发票系统</td></tr>
<tr><td>26.10 附录：关于适配器模式与装饰模式的对话</td></tr>

<tr>
<td rowspan=6>第27章 专题：设计模式在Java I/O库中的应用</td>
<td>27.1 引言</td>
</tr>
<tr><td>27.2 Java I/O库的设计原则</td></tr>
<tr><td>27.3 装饰模式的应用</td></tr>
<tr><td>27.4 半透明的装饰模式</td></tr>
<tr><td>27.5 适配器模式的应用</td></tr>
<tr><td>27.6 从byte流到char流的适配</td></tr>

<tr>
<td rowspan=9>第28章 代理（Proxy）模式</td>
<td>28.1 引言</td>
</tr>
<tr><td>28.2 代理的种类</td></tr>
<tr><td>28.3 代理模式的结构</td></tr>
<tr><td>28.4 代理模式的时序</td></tr>
<tr><td>28.5 Java 2.0对代理模式的支持</td></tr>
<tr><td>28.6 高老庄悟空降八戒</td></tr>
<tr><td>28.7 代理模式的优点和缺点</td></tr>
<tr><td>28.8 代理模式的实现</td></tr>
<tr><td>28.9 代理模式与其他模式的关系</td></tr>

<tr>
<td rowspan=4>第29章 专题：智能引用代理</td>
<td>29.1 问题</td>
</tr>
<tr><td>29.2 系统设计</td></tr>
<tr><td>29.3 系统的时序</td></tr>
<tr><td>29.4 系统的源代码</td></tr>

<tr>
<td rowspan=5>第30章 专题：虚拟代理的例子</td>
<td>30.1 问题</td>
</tr>
<tr><td>30.2 系统的要求</td></tr>
<tr><td>30.3 系统的设计</td></tr>
<tr><td>30.4 系统的时序</td></tr>
<tr><td>30.5 系统的源代码</td></tr>

<tr>
<td rowspan=10>第31章 享元模式（Flyweight Pattern）</td>
<td>31.1 引言</td>
</tr>
<tr><td>31.2 单纯享元模式的结构</td></tr>
<tr><td>31.3 复合享元模式的结构</td></tr>
<tr><td>31.4 模式的实现</td></tr>
<tr><td>31.5 一个咖啡摊的例子</td></tr>
<tr><td>31.6 咖啡屋的例子</td></tr>
<tr><td>31.7 享元模式应当在什么情况下使用</td></tr>
<tr><td>31.8 从代码重构的角度看享元模式</td></tr>
<tr><td>31.9 享元模式的优点和缺点</td></tr>
<tr><td>31.10 相关的模式</td></tr>

<tr>
<td rowspan=8>第32章 门面（Facade）模式</td>
<td>32.1 引言</td>
</tr>
<tr><td>32.2 门面模式的结构</td></tr>
<tr><td>32.3 门面模式的实现</td></tr>
<tr><td>32.4 在什么情况下使用门面模式</td></tr>
<tr><td>32.5 迪米特法则（LoD）</td></tr>
<tr><td>32.6 一个例子</td></tr>
<tr><td>32.7 使用门面模式的设计</td></tr>
<tr><td>32.8 Session门面模式</td></tr>

<tr>
<td rowspan=9>第33章 桥梁（Bridge）模式</td>
<td>33.1 引言</td>
</tr>
<tr><td>33.2 桥梁模式的结构</td></tr>
<tr><td>33.3 Java语言中的Peer架构</td></tr>
<tr><td>33.4 驱动器和JDBC驱动器</td></tr>
<tr><td>33.5 从重构的角度考察</td></tr>
<tr><td>33.6 桥梁模式和其他模式的关系</td></tr>
<tr><td>33.7 八戒“转世投胎”的故事</td></tr>
<tr><td>33.8 关于桥梁模式的实现</td></tr>
<tr><td>33.9 在什么情况下应当使用桥梁模式</td></tr>

<tr>
<td rowspan=143>第五部分</td>
<td rowspan=6>第34章 不变（Immutable）模式</td>
<td>34.1 引言</td>
</tr>
<tr><td>34.2 不变模式的结构和实现</td></tr>
<tr><td>34.3 不变模式在Java语言中的应用</td></tr>
<tr><td>34.4 不变模式的优点和缺点</td></tr>
<tr><td>34.5 不变模式与享元模式的关系</td></tr>
<tr><td>34.6 一个例子：复数类</td></tr>

<tr>
<td rowspan=10>第35章 策略（Strategy）模式</td>
<td>35.1 引言</td>
</tr>
<tr><td>35.2 模式的实现</td></tr>
<tr><td>35.3 Java语言内部的例子</td></tr>
<tr><td>35.4 排序策略系统</td></tr>
<tr><td>35.5 一个例子：图书折扣的计算</td></tr>
<tr><td>35.6 在什么情况下应当使用策略模式</td></tr>
<tr><td>35.7 策略模式的优点和缺点</td></tr>
<tr><td>35.8 策略模式与其他模式的关系</td></tr>
<tr><td>35.9 设计原则的讨论</td></tr>
<tr><td>35.10 诸葛亮的锦囊妙计</td></tr>

<tr>
<td rowspan=10>第36章 模板方法（Template Method）模式</td>
<td>36.1 引言</td>
</tr>
<tr><td>36.2 模板方法模式的结构</td></tr>
<tr><td>36.3 “好莱坞原则”</td></tr>
<tr><td>36.4 一个例子</td></tr>
<tr><td>36.5 继承作为复用的工具</td></tr>
<tr><td>36.6 Java语言里面使用过的模板方法模式</td></tr>
<tr><td>36.7 模板方法模式中的方法</td></tr>
<tr><td>36.8 模板方法模式在代码重构中的应用</td></tr>
<tr><td>36.9 重构的原则</td></tr>
<tr><td>36.10 西天取经的八十一难</td></tr>

<tr>
<td rowspan=3>第37章 专题：Servlet技术中的模式</td>
<td>37.1 Servlet技术介绍</td>
</tr>
<tr><td>37.2 模板方法模式的使用</td></tr>
<tr><td>37.3 观察者模式的应用</td></tr>

<tr>
<td rowspan=7>第38章 观察者（Observer）模式</td>
<td>38.1 引言</td>
</tr>
<tr><td>38.2 观察者模式的结构</td></tr>
<tr><td>38.3 另一种实现方案</td></tr>
<tr><td>38.4 Java语言提供的对观察者模式的支持</td></tr>
<tr><td>38.5 菩萨的守瓶龟</td></tr>
<tr><td>38.6 Java中的DEM事件机制</td></tr>
<tr><td>38.7 观察者模式与其他模式的关系</td></tr>

<tr>
<td rowspan=2>第39章 专题：观察者模式与AWT中的事件处理</td>
<td>39.1 引言</td>
</tr>
<tr><td>39.2 DEM的结构</td></tr>

<tr>
<td rowspan=7>第40章 专题：观察者热模式与SAX2浏览器</td>
<td>40.1 引言</td>
</tr>
<tr><td>40.2 SAX2是怎么工作的</td></tr>
<tr><td>40.3 ContentHandler接口</td></tr>
<tr><td>40.4 怎样实现ContentHandler接口</td></tr>
<tr><td>40.5 怎样使用ContentHandler</td></tr>
<tr><td>40.6 缺省适配模式与DefaultHandler</td></tr>
<tr><td>40.7 简单工厂模式的应用</td></tr>

<tr>
<td rowspan=5>第41章 专题：观察者模式与Swing定时器</td>
<td>41.1 为什么需要定时器</td>
</tr>
<tr><td>41.2 Utility定时器与Swing定时器的区别</td></tr>
<tr><td>41.3 使用Swing定时器的方法</td></tr>
<tr><td>41.4 观察者模式的应用</td></tr>
<tr><td>41.5 单例模式的应用</td></tr>

<tr>
<td rowspan=6>第42章 专题：MVC模式与用户输入数据检查</td>
<td>42.1 什么是MVC模式</td>
</tr>
<tr><td>42.2 MVC是架构模式</td></tr>
<tr><td>42.3 MVC模式在J2EE技术中的应用</td></tr>
<tr><td>42.4 从代码重构的角度查看</td></tr>
<tr><td>42.5 用户输入检查与MVC模式</td></tr>
<tr><td>42.6 SQL注射</td></tr>

<tr>
<td rowspan=6>第43章 迭代子（Iterator）模式</td>
<td>43.1 引言</td>
</tr>
<tr><td>43.2 迭代子模式的结构</td></tr>
<tr><td>43.3 迭代子模式的实现</td></tr>
<tr><td>43.4 迭代子模式的优点和缺点</td></tr>
<tr><td>43.5 一个例子</td></tr>
<tr><td>43.6 迭代子模式与其他模式的关系</td></tr>


<tr>
<td rowspan=6>第44章 专题：Java对迭代子模式的支持</td>
<td>44.1 Java聚集</td>
</tr>
<tr><td>44.2 Java聚集中的迭代子</td></tr>
<tr><td>44.3 java.util.Iterator接口</td></tr>
<tr><td>44.4 Java迭代子接口ListIterator</td></tr>
<tr><td>44.5 Enumeration与Iterator</td></tr>
<tr><td>44.6 其他相关模式</td></tr>

<tr>
<td rowspan=10>第45章 责任链（Chain of Responsibility）模式</td>
<td>45.1 从击鼓传花谈起</td>
</tr>
<tr><td>45.2 责任链模式的结构</td></tr>
<tr><td>45.3 纯的与不纯的责任链模式</td></tr>
<tr><td>45.4 Java 1.0版本的AWT事件处理机制</td></tr>
<tr><td>45.5 『红楼梦』中击鼓传花的故事</td></tr>
<tr><td>45.6 Java系统的解</td></tr>
<tr><td>45.7 责任链模式的实现</td></tr>
<tr><td>45.8 对象的树结构</td></tr>
<tr><td>45.9 DHTML中的事件处理</td></tr>
<tr><td>45.10 责任链模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第46章 专题：定时器与击鼓传花</td>
<td>46.1 线程</td>
</tr>
<tr><td>46.2 定时器</td></tr>
<tr><td>46.3 击鼓传花</td></tr>

<tr>
<td rowspan=11>第47章 命令（Command）模式</td>
<td>47.1 引言</td>
</tr>
<tr><td>47.2 命令模式的结构</td></tr>
<tr><td>47.3 玉帝传美猴王上天</td></tr>
<tr><td>47.4 Java语言内的例子：AWT的事件处理</td></tr>
<tr><td>47.5 一个例子：创世纪系统</td></tr>
<tr><td>47.6 一个例子：AudioPlayer系统</td></tr>
<tr><td>47.7 增加宏命令功能</td></tr>
<tr><td>47.8 模式的实现</td></tr>
<tr><td>47.9 在什么情况下应当使用命令模式</td></tr>
<tr><td>47.10 使用命令模式的优点和缺点</td></tr>
<tr><td>47.10 命令模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第48章 专题：Swing库中的命令撤销和恢复</td>
<td>48.1 在视窗系统中使用命令模式</td>
</tr>
<tr><td>48.2 Swing的基本撤销功能</td></tr>
<tr><td>48.3 一休论禅的文字框</td></tr>

<tr>
<td rowspan=12>第49章 备忘录（Memento）模式</td>
<td>49.1 备忘录模式的结构</td>
</tr>
<tr><td>49.2 备忘录模式的白箱实现</td></tr>
<tr><td>49.3 双重接口及其在Java语言中的实现</td></tr>
<tr><td>49.4 备忘录模式的黑箱实现</td></tr>
<tr><td>49.5 责任人角色的增强</td></tr>
<tr><td>49.6 备忘录模式与多重检查点</td></tr>
<tr><td>49.7 “自述历史”模式</td></tr>
<tr><td>49.8 “假如”协议模式</td></tr>
<tr><td>49.9 备忘录模式与其他模式的关系</td></tr>
<tr><td>49.10 备忘录模式的应用</td></tr>
<tr><td>49.11 使用备忘录模式的优点和缺点</td></tr>
<tr><td>49.12 观世音甘泉活树的故事</td></tr>

<tr>
<td rowspan=10>第50章 状态（State）模式</td>
<td>50.1 引言</td>
</tr>
<tr><td>50.2 状态模式的结构</td></tr>
<tr><td>50.3 曾侯乙编钟的描述</td></tr>
<tr><td>50.4 状态模式的效果</td></tr>
<tr><td>50.5 在什么情况下使用状态模式</td></tr>
<tr><td>50.6 关于模式实现的讨论</td></tr>
<tr><td>50.7 一个状态模式的应用例子：TCP</td></tr>
<tr><td>50.8 状态模式在绘图软件中的应用</td></tr>
<tr><td>50.9 用户登录子系统</td></tr>
<tr><td>50.10 状态模式与策略模式的区别</td></tr>

<tr>
<td rowspan=3>第51章 专题：崂山道士与状态模式</td>
<td>51.1 有状态的墙</td>
</tr>
<tr><td>51.2 异常逻辑</td></tr>
<tr><td>51.3 从代码重构的角度考察</td></tr>

<tr>
<td rowspan=3>第52章 专题：单分派和多分派</td>
<td>52.1 分派的概念</td>
</tr>
<tr><td>52.2 双重分派</td></tr>
<tr><td>52.3 未来的Java语言</td></tr>

<tr>
<td rowspan=9>第53章 访问者（Visitor）模式</td>
<td>53.1 引言</td>
</tr>
<tr><td>53.2 访问者模式的结构</td></tr>
<tr><td>53.3 系统的时序图</td></tr>
<tr><td>53.4 在什么情况下应当使用访问者模式</td></tr>
<tr><td>53.5 使用访问者模式的优点和缺点</td></tr>
<tr><td>53.6 访问者模式的实现</td></tr>
<tr><td>53.7 电脑专卖系统：问题与对象</td></tr>
<tr><td>53.8 电脑专卖系统的访问者模式设计</td></tr>
<tr><td>53.9 与访问者模式有关的模式</td></tr>

<tr>
<td rowspan=4>第54章 解释器（Interpreter）模式</td>
<td>54.1 引言</td>
</tr>
<tr><td>54.2 解释器模式的结构</td></tr>
<tr><td>54.3 一个示意性的实现</td></tr>
<tr><td>54.4 有关模式</td></tr>

<tr>
<td rowspan=7>第55章 调停者（Mediator）模式</td>
<td>55.1 引言</td>
</tr>
<tr><td>55.2 调停者模式的结构</td></tr>
<tr><td>55.3 调停者模式的实现</td></tr>
<tr><td>55.4 迪米特法则（LoD）</td></tr>
<tr><td>55.5 调停者模式的优点和缺点</td></tr>
<tr><td>55.6 调停者模式的使用条件</td></tr>
<tr><td>55.7 与调停者模式有关的模式</td></tr>

<tr>
<td rowspan=5>附录</td>
<td rowspan=3>附录A 设计模式一览表</td>
<td>A.1 创建模式</td>
</tr>
<tr><td>A.2 结构模式</td></tr>
<tr><td>A.3 行为模式</td></tr>

<tr>
<td rowspan=1>附录B UML图标及Java实现</td>
<td>一览表</td>
</tr>

<tr>
<td colspan=2>附录C 中英术语对照表</td>
</tr>
</table>

# 第一部分



## 第1章 模式的简史和形而上学



### 1.1 模式是什么



### 1.2 软件模式的简史



### 1.3 模式的起源



### 1.4 与道家思想的关系



### 1.5 软件的永恒之道



### 1.6 模式的要素



### 1.7 本书讲解模式的格式



## 第2章 统一建模语言UML简介



### 2.1 建造世界贸易中心



### 2.2 什么是UML



### 2.3 UML包括什么



### 2.4 类图



### 2.5 时序图



### 2.6 状态图



### 2.7 UML及建模的工具



# 第二部分



## 第3章 软件的可维护性与可复用性



### 3.1 软件系统的可维护性



### 3.2 系统的可复用性



### 3.3 老子论“不武”



## 第4章 “开 - 闭”原则（OCP）



### 4.1 什么是“开 - 闭”原则



### 4.2 怎样做到“开 - 闭”原则



### 4.3 与其他设计原则的关系



### 4.4 策略模式对“开 - 闭”原则的支持



### 4.5 在其他设计模式中的体现



### 4.6 一个重构做法的讨论



## 第5章 专题：Java语言的接口



### 5.1 什么是接口



### 5.2 为什么使用接口



### 5.3 Java接口常见的用法



## 第6章 专题：抽象类



### 6.1 什么是抽象类



### 6.2 抽象类的用途



### 6.3 基于抽象类的模式和原则



### 6.4 什么时候才应当使用继承复用



## 第7章 里氏代换原则（LSP）



### 7.1 美猴王的智慧



### 7.2 什么是里氏代换原则



### 7.3 里氏代换原则在设计模式中的体现



### 7.4 墨子论“取譬”



### 7.5 从代码重构的角度理解



## 第8章 依赖倒转原则（DIP）



### 8.1 为何而“倒转”



### 8.2 复用与可维护性的倒转



### 8.3 依赖倒转原则



### 8.4 怎样做到依赖倒转原则



### 8.5 Java对抽象类型的支持



### 8.6 一个例子：账号、账号的种类和账号的状态



### 8.7 墨子论“取周”



### 8.8 依赖倒转原则的优缺点



## 第9章 接口隔离原则（ISP）



### 9.1 什么是接口隔离原则



### 9.2 一个角色隔离原则的例子



### 9.3 定制服务的例子



## 第10章 合成/聚合复用原则（CARP）



### 10.1 合成和聚合的区别



### 10.2 复用的基本种类



### 10.3 从代码重构的角度理解



## 第11章 迪米特法则（LoD）



### 11.1 迪米特法则的各种表述



### 11.2 狭义的迪米特法则



### 11.3 迪米特法则与设计模式



### 11.4 广义的迪米特法则



### 11.5 广义迪米特法则在类的设计上的体现



### 11.6 广义迪米特法则在代码层次上的实现



### 11.7 老子论“圣人之治”



# 第三部分 创建模式

<p>创建模式（Createional Pattern）是对类的实例化过程的抽象化。</p>
<p>一些系统在创建对象时，需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。</p>
<p>创建模式描述了怎样构造和封装这些动态的决定。</p>

<table>
<caption>创建模式分两类</caption>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
<tr>
<td>类的创建模式</td>
<td>
使用继承关系把类的创建延迟到子类<br>
从而封装了客户端将得到哪些具体类的信息<br>
并且隐藏了这些类的实例是如何被创建和放在一起的
</td>
</tr>
<tr>
<td>对象的创建模式</td>
<td>
把对象的创建过程动态的委派给另一个对象<br>
从而动态的决定客户端将得到哪些具体类的实例<br>
以及这些类的实例是如何被创建和组合在一起的<br>
</td>
</tr>
</table>

<p>下面将介绍以下创建模式及专题：</p>

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 单例模式（专题：单例模式与MX记录）
* 多例模式（专题：序列键生成器与单例及多例模式）
* 建造模式
* 原始模型模式（专题：JavaBean的“冷藏”和“解冻”）

## 第12章 简单工厂（Simple Factory）模式

<p>简单工厂模式是类的创建模式，是由一个工厂对象决定创建出哪一种产品类的实例</p>

### 12.1 工厂模式的几种形态

* 简单工厂(Simple Factory)模式又叫静态工厂方法模式(Static Factory Method Pattern)
* 工厂方法(Factory Method)模式又叫多态工厂(Polymorphic Factory)模式或者虚拟构造子(Virtual Constructor)模式
* 抽象工厂(Abstract Factory)模式又叫工具箱(Kit or Toolkit)模式

<p>简单工厂模式是工厂方法模式的一个特殊实现。</p>

### 12.2 简单工厂模式的引进

<p>如下是一套完整的演示代码：</p>

<kbd>Fruit.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public interface Fruit {
    /*
     * 种植
     * */
    void plant();
    /*
    * 生长
    * */
    void grow();
    /*
     * 收货
     * */
    void harvest();
}
```
<kbd>Apple.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Apple implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Apple.class);

    private int treeAge;

    @Override
    public void plant() {
        LOG.info("Apple has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Apple is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Apple has benn harvested.");
    }

    public int getTreeAge() {
        return treeAge;
    }

    public void setTreeAge(int treeAge) {
        this.treeAge = treeAge;
    }
}
```

<kbd>Grape.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Grape implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Grape.class);

    private boolean seedless;

    @Override
    public void plant() {
        LOG.info("Grape has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Grape is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Grape has benn harvested.");
    }

    public boolean isSeedless() {
        return seedless;
    }

    public void setSeedless(boolean seedless) {
        this.seedless = seedless;
    }
}
```

<kbd>Strawberry.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Strawberry implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Strawberry.class);

    @Override
    public void plant() {
        LOG.info("Grape has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Grape is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Grape has benn harvested.");
    }
}
```

<kbd>BadFruitException.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public class BadFruitException extends Exception {
    public BadFruitException(String message) {
        super(message);
    }
}
```

<kbd>FruitGardener.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public class FruitGardener {
    public static Fruit factory(String which) throws BadFruitException {
        if ("apple".equalsIgnoreCase(which)) {
            return new Apple();
        } else if ("grape".equalsIgnoreCase(which)) {
            return new Grape();
        } else if ("strawberry".equalsIgnoreCase(which)) {
            return new Strawberry();
        } else {
            throw new BadFruitException("Bad fruit request");
        }
    }
}
```

<kbd>FruitGardenerTest.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import junit.framework.TestCase;
import org.junit.Test;

public class FruitGardenerTest extends TestCase {

    @Test
    public void testFactory() {
        try {
            Fruit fruit = FruitGardener.factory("Apple");
            assertTrue(fruit instanceof Apple);

            fruit = FruitGardener.factory("Grape");
            assertTrue(fruit instanceof Grape);

            fruit = FruitGardener.factory("Strawberry");
            assertTrue(fruit instanceof Strawberry);

            FruitGardener.factory("something");

        } catch (Exception e) {
            assertTrue(e instanceof BadFruitException);
        }
    }
}
```

### 12.3 简单工厂模式的结构

<p>简单工厂模式是<kbd>类</kbd>的创建模式，这个模式的一般性结构如下图所示：</p>

<img src="./image/12.03.001.svg"/>

#### 12.3.1 角色与结构

<p>简单工厂模式就是由一个工厂类根据传入的参量决定创建出哪一种产品类的示例。</p>
<p>下面以一个示意性的实现为例说明简单工厂模式的结构。</p>
<p>如下图所示：</p>

<img src="./image/12.03.002.svg"/>

<pre>
concrete
英 [ˈkɒŋkriːt]
美 [ˈkɑːŋkriːt]  
n. 混凝土
adj. 混凝土制的;确实的，具体的(而非想象或猜测的);有形的;实在的
vt. 用混凝土覆盖
</pre>

<p>从上图可以看出，简单工厂模式涉及到以下三个角色：</p>

<table>
<tr>
<td>工厂类（Creator）角色</td>
<td>
担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的业务逻辑。</br>
工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。
</td>
</tr>
<tr>
<td>抽象产品（Product）角色</td>
<td>
担任这个角色的类是由工厂方法模式所创建的对象的父类，或他们共同拥有的接口。</br>
抽象产品角色可以用一个Java接口或者Java抽象类实现。
</td>
</tr>
<tr>
<td>具体产品（Concrete Product）角色</td>
<td>工厂方法模式所创建的任何对象都是这个角色的实例，具体产品角色由一个Java类实现。</td>
</tr>
</table>

#### 12.3.2 源代码

<kbd>Product.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public interface Product {
}
```

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public class ConcreteProduct implements Product {
    public ConcreteProduct() {
    }
}
```

<kbd>Creator.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public class Creator {
    /*
     * 静态工厂方法
     * */
    public static Product factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>CreatorTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

import junit.framework.TestCase;
import org.junit.Test;

public class CreatorTest extends TestCase {
    @Test
    public void testFactory() {
        Product product = Creator.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

### 12.4 简单工厂模式的实现

#### 12.4.1 多层次的产品结构

<p>真实系统中，产品具有复杂的等级结构</p>
<p>如下，树形结构中具有多个抽象产品和具体产品类</p>
<img src="./image/12.04.001.svg"/>
<p>如示例，简单工厂模式采用以不变应万变的策略，一律使用同一个工厂类。</p>
<p>优点：设计简单，产品类的等级结构不会反映到工厂类中来，从而产品的等级结构的变化也不会影响到工厂类。</p>
<p>缺点：增加新的产品时也需要修改工厂类。</p>

#### 12.4.2 使用Java接口或者Java抽象类

<p>如果模式所生产的具体产品类之间没有共同的业务逻辑，那么抽象产品角色可以是一个Java接口</p>
<p>反之，抽象产品角色应该是一个抽象类，这些公有的业务逻辑应统一放到抽象类中。</p>
<img src="./image/12.04.002.svg"/>

#### 12.4.3 多个工厂方法

<p>工厂类可以有多个工厂方法，分别负责创建不同的产品对象。</p>
<p>比如：java.text.DateFormat类是其子类的工厂类，并且提供了多个静态工厂方法。</p>

#### 12.4.4 抽象产品角色的省略

<p>如果系统仅有一个具体产品角色，可以省略抽象产品角色。</p>
<p>类图如下：</p>
<img src="./image/12.04.003.svg"/>
<p>示例代码如下：</p>

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

public class ConcreteProduct {
    public ConcreteProduct() {
    }
}
```

<kbd>Creator.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

public class Creator {
    /*
    * 静态工厂方法
    * */
    public static ConcreteProduct factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>CreatorTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

import junit.framework.TestCase;
import org.junit.Test;

public class CreatorTest extends TestCase {
    @Test
    public void testFactory() {
        ConcreteProduct product = Creator.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

#### 12.4.5 工厂角色与抽象产品角色合并

<p>某些情况下，工厂角色可以由抽象产品角色扮演。</p>
<p>典型的应用就是java.text.DateFormat类，一个抽象产品类，同时也是子类的工厂。</p>
<img src="./image/12.04.004.svg"/>
<p></p>

#### 12.4.6 三个角色全部合并

<p>如果抽象产品角色已经被省略，那工厂角色就可以与具体产品角色合并。</p>
<p>即，一个产品类为自身的工厂。</p>
<img src="./image/12.04.005.svg"/>
<p>三个原本独立的角色：抽象产品，具体产品，工厂类都已经合并为一个类，这个类自行创建自己的实例，代码如下：</p>

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example4;

public class ConcreteProduct {
    public ConcreteProduct() {
    }

    /*
    * 静态工厂方法
    * */
    public static ConcreteProduct factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>ConcreteProductTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example4;

import junit.framework.TestCase;
import org.junit.Test;

public class ConcreteProductTest extends TestCase {
    @Test
    public void testFactory() {
        ConcreteProduct product = ConcreteProduct.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

#### 12.4.7 产品对象的循环使用和登记式的工厂方法

<p>简单工厂模式是一个非常基本的设计模式，因此它会在较为复杂的设计模式中出现。本章之前给出的示例，工厂方法总是简单的调用产品类的构造子来创建新的产品实例，然后返回给客户端，而在实际场景中，工厂方法做的事情可以相当复杂。</p>
<p>在本书所讨论的所有设计模式中，单例模式与多例模式是建立在简单工厂模式的基础上的，并且要求工厂方法具有特殊逻辑，以便能够循环使用产品的实例。</p>
<p>很多情况下，产品对象可以循环使用。换言之，工厂方法可以奴化您使用自己已经创建出来的对象，而不是每次一次都创建新的产品对象。工厂方法可以通过登记他所创建的产品对象来达到循环使用产品对象的目的。</p>
<p>如果工厂方法总是循环使用同一个产品对象，那么这个工厂对象可以使用一个属性来存储这个产品对象。每次客户端调用工厂方法时，工厂方法总是提供这同一个对象。单例模式中就是这样，单例类提供一个静态工厂方法，向外界提供一个唯一的单例类示例。</p>
<p>如果工厂方法永远循环使用固定数目的一些产品对象，而且这些产品对象的数目并大的话，可以使用一些私有属性存储这些产品对象的引用。比如：一个永远只提供一个产品对象的工厂对象可以使用一个静态变量存储这个产品对象的引用。</p>
<p>相反，如果工厂方法使用数目不确定，或者数目较大的一些产品对象的话，使用属性存储这些产品对象的引用就不方便了。这时，就应该使用集合对象存储对产品对象的引用。</p>
<p>无论使用哪种方法，工厂对象都能做到循环使用它所创建的对象。循环的逻辑可能是基于这些产品类的内部状态，比如某一种产品的对象只创建一个，让所有需要处于这个状态上的产品对象的客户端共享这一个实例。</p>

### 12.5 简单工厂模式与其他模式的关系

#### 12.5.1 单例模式

<p>单例模式使用了简单工厂模式。即，单例类具有一个静态工厂方法提供自身的实例。一个抽象产品类同时是子类的工厂。如下图：</p>
<img src="./image/12.05.001.svg"/>
<p>单例模式并不是简单工厂模式的退化场情形，单例模式要求单例类的构造器是私有的，从而限制客户端不能直接将其实例化，必须通过这个静态工厂方法将之实例化，而单例类自身是自己的工厂角色。即，单例类自己负责构造自己的实例。</p>
<p>单例类使用一个静态的属性存储自己的唯一实例，工厂方法永远只提供这有一个实例。</p>

#### 12.5.2 多例模式

<p>多例模式是对单例模式的推广。多例模式与单例模式的共同点是它们都禁止外界直接直接将之实例化，同时通过静态工厂方法向外界提供循环使用的自身的实例。他们的不同在于单例模式只有与一个实例，二多例模式可以有多个实例。</p>
<p>多例模式往往具有一个集合属性，通过这个集合属性登记已经创建过的实例达到循环使用的目的。一般而言，一个典型的多例类具有某种内部状态，这个内部状态可用来区分各个实例，而对应于每一个内部状态，都只有一个实例存在。</p>
<p>根据外界传入的参数，工厂方法可以查询自己的登记集合，如果具有这个状态的实例已经存在，就直接将这个实例提供给外界；反之，就首先创建一个新的满足要求的实例，将之登记到集合中，然后再提供给客户端。</p>
<p>还会有后续章节详细介绍单例模式和多例模式。</p>

#### 12.5.3 备忘录模式

<p>单例模式和多例模式使用一个属性或集合来登记所创建的产品对象，以便可以通过查询这个属性或者集合属性找到并共享已经创建了的产品对象，这就是备忘录模式的应用。备忘录模式的简略类图如下：</p>
<img src="./image/12.05.002.svg"/>

#### 12.5.4 MVC模式

<p>MVC模式并不是严格意义上的设计模式，而是更高层次上的架构模式。MVC模式可以分解为几个设计模式的组合：合成模式、策略模式、观察者模式，也可能会包括装饰模式、调停者模式、迭代子模式以及工厂方法模式等。MVC模式的结构图如下所示。后续还会有专门的章节讨论。</p>
<img src="./image/12.05.003.svg"/>
<p>简单工厂模式所创建的对象往往属于一个产品等级结构，这个等级结构可以是MVC模式中的视图(View)，而工厂角色本身可以是控制器(Controller)。一个MVC模式可以有一个控制器和多个视图，如下图所示：</p>
<img src="./image/12.05.004.svg"/>
<p>即，控制器端可以创建合适的视图端，就如同工厂角色创建合适的对象角色一样，而模型端则可以充当这个创建过程的客户端。</p>
<p>如果系统需要有多个控制器参与这个过程的话，简单工厂模式就不适合了，应当考虑使用工厂方法模式。工厂方法模式后续章节有介绍。</p>

### 12.6 简单工厂模式的优点和缺点

#### 12.6.1 简单工厂模式的优点

<p>模式的核心是工厂类，这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的示例。而客户端则可以免除直接创建产品对象的责任，而仅仅负责“消费”产品，简单工厂模式通过这种做法实现了对责任的分割。</p>

#### 12.6.2 简单工厂模式的缺点

<p>如本章前部分讨论，当产品类有复杂的多层次等级结构时，工厂类只有它自己。以不变应万变，这就是模式的缺点。</p>
<p>这个工厂类集中了所有的产品创建逻辑，形成一个无所不知的全能类，有人把这种类叫做上帝类（God Class）。如果这个类代表的是农场的一个具体园丁的话，那么这个园丁就需要对所有的产品负责，成了农场的关键人物，他什么时候不能正常工作了，整个农场都要受影响。</p>
<p>将这么多逻辑集中放在一个类里面的另外一个缺点是，当产品类有不同的接口种类时，工厂类需要判断在什么时候创建某种产品。这种对时机的判断和对哪一种具体产品的判断逻辑混合在一起，使得系统在将来进行功能扩展时较为困难。这一缺点在工厂方法模式中得到克服。</p>
<p>由于简单工厂模式使用静态方法作为工厂方法，而静态方法无法由子类继承，因此工厂角色无法行程基于继承的等级结构。这一缺点会在工厂方法模式中得到克服。</p>

#### 12.6.3 “开-闭”原则

<p>“开-闭”原则要求一个系统的设计能够允许系统在无需修改的情况下，扩展其功能。简单工厂模式是否满足这个条件呢？</p>
<p>将简单工厂模式系统划分成不同的子系统，再考虑功能扩展对于这些子系统的要求。一般而言，一个系统总是可以划分成为产品的消费者角色（Client）、产品的工厂角色（Factory）、以及产品角色（Product）三个子系统，如下图所示：</p>
<img src="./image/12.06.001.svg"/>
<p>在这个系统中，功能的扩展体现在引进新的产品上。“开-闭”原则要求系统允许当新的产品加入系统中时，无需对现有代码进行修改。这一点对于产品的消费角色是成立的，而对于工厂角色不成立。</p>
<p>对于产品消费角色来说，任何时候需要某种产品，只需向工厂角色申请即可。而工厂角色在接到申请后，会自行判断创建和提供哪一个产品。所以产品消费角色无需知道他得到的是哪一个产品；即，产品消费角色无需修改就可以接纳新的产品。</p>
<p>对于工厂角色来说，增加新的产品是一个痛苦的过程。工厂角色必须知道每一种产品，如何创建它们，以及何时向客户端提供它们。即：接纳新产品就意味着要修改这个工厂角色的源代码。</p>
<p>综本章所述，简单工厂角色只在有限程度上支持“开-闭”原则。</p>

### 12.7 简单工厂模式在Java中的应用

<p>简单工厂模式是一个很基本的设计模式，在Java语言的API中就能看到这个模式的应用。</p>

#### 12.7.1 DateFormat与简单工厂模式

<p>工具类java.text.DateFormat或其子类可以用来格式化一个本地日期或者时间，这个工具类在处理英语和非英语的日期及时间格式上很有用处。</p>

##### 12.7.1.1 使用的目的

<p>在本地机器上，时间和日期的格式存在一些标准风格。日期的格式化风格如下：</p>

* SHORT 代表完全是数字的短格式，如：[1/20/2002]或者[15:20]
* MEDIUM 代表把缩写文字加到端格式中，如：[Jul 22, 2022]或者[3:20pm]
* LONG 代表长格式，完整的词，如：[July 2, 2022]或者[3:20:10pm]
* FULL 代表全格式，包括了完整的日期信息，如：[Monday, July 22, 2022, AD]或者[3:20:10pm EST]

<p>DateFormat与SimpleDateFormat的类图如下所示：</p>

<img src="./image/12.07.001.svg"/>

> 图中好多方法名字对不上,不确定是不是原书编排错误，不过不影响上下文逻辑表达。

<p>DateFormat类是个抽象类，提供很多静态工厂方法，如：getDateInstance()，提供三个重载方法</p>

【代码清单14】

```java
    public static final DateFormat getDateInstance();
    public static final DateFormat getDateInstance(int style);
    public static final DateFormat getDateInstance(int style, Locale locale);
```

<p>这个抽象类通过几个静态方法提供自己的实例(抽象类是不能有自己的实例的，这里有玄机)。注意DateFormat的工厂方法是静态方法。</p>
<p>getDateInstance()方法作为一个工厂方法，并没有调用DateFormat的构造器来提供自己的实例，作为一个工厂方法，做了两件事：一是运用多态，二是使用静态工厂方法。</p>
<p>从上面给出的类图可看出SimpleDateFormat是DateFormat的子类型，所以getIndstance()方法可以以DateFormat返回SimpleDateFormat的实例，这是典型的多态原则的应用。</p>
<p>getInstance()方法必须是静态，客户端否则必须先实例化才能调用。但是父类是抽象类，只能实例化子类。而这是矛盾的。</p>
<p>这里使用静态工厂方法是为了把具体子类实例化的工作隐藏起来，客户端不必考虑如何将具体子类实例化，由父类负责提供合适的具体子类的实例，这是个典型的简单工厂的应用。</p>

##### 12.7.1.2 针对抽象编程

<p>利用具体产品的超类类型将它的真实类型隐藏起来，好处是提供了系统的可扩展性。如果将来有新的具体子类被加入到系统中来，工厂类可以透明的把交给客户端的对象换成新的子类的实例。</p>
<p>这种把工厂方法返回的类型设置成抽象产品类型的做法，叫做针对抽象编程，这是依赖倒转原则（DIP）的应用。详细介绍见本书章节“依赖倒转原则（DIP）”一章。</p>

##### 12.7.1.3 本地时间

<p>与本地日期格式化相对应的是微某种本地时间提供格式化，具体代码见上个代码块【代码清单14】。</p>
<p>它自身是个抽象类，不可能有自己的实例。所以他们也是提供子类的实例而不是自身的实例。由于其子类必然是DateFormat的子类型，因此返还类型可以是DateFormat类型，这是多态的体现。</p>

##### 12.7.1.4 一个语法日期的例子

<p>下面给出这个工具类的使用示例。这里假定本地语言是发育，并针对法语进行时间和日期的格式化。</p>

```java
package com.benson.note.pij.construct.simplefactory.example5;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

public class DateTester {

    public static void main(String[] args) {
        Locale local = Locale.FRENCH;
        Date date = new Date();
        String now = DateFormat.getTimeInstance(DateFormat.DEFAULT, local).format(date);
        System.out.println(now);
        try {
            date = DateFormat.getDateInstance(DateFormat.DEFAULT, local).parse("16 nov. 01");
            System.out.println(date);
        } catch (Exception e) {
            System.out.println("Parsing exception : " + e);
        }
    }
}
```

<p>now 包含了按照法语格式写出的当前时间，而date则读入了以法语方式书写的一个日期“16 nov. 01”。打印结果如下：</p>

```
14:00:56
Wed Nov 16 00:00:00 CST 1
```

##### 12.7.1.5 简单工厂模式的应用

<p>从上述示例可以看到，由于使用了简单工厂模式，客户端完全不必要操心工厂方法所返回的对象是怎样创建和构成的。工厂方法将实例化哪些对象以及如何实例化这些对象的细节隐藏起来，简化了对这些对象的使用。</p>
<p>与一般简单工厂模式不同的地方在于，这里的工厂角色与抽象产品角色合并成一个类。也就是说，抽象产品角色负责具体产品角色的创建，这是简单工厂模式的一个特例。</p>

<img src="./image/12.07.002.svg"/>

#### 12.7.2 SAX2库中的XMLReaderFactory与简单工厂模式

<p>在SAX2库中，XMLReaderFactory类使用了简单工厂模式，用来创建产品类XMLReader的实例。下面是相应的类图。</p>

<img src="./image/12.07.003.svg"/>

<p>XMLReaderFactory提供了两种不同的静态方法，适用于不同的驱动软件参数。关于SAX2库的知识以及SAX2库所涉及到的其他模式大讨论，参考本书其他章节“专题：XMLProperties与适配器模式”和“专题：观察者模式与SAX2浏览器”。</p>

### 12.8 女娲抟(tuan2)土造人

<p>《风俗通》中说：“俗说天地开辟，未有人民。女娲抟黄土以为人。” 女娲需要用土造出一个个的人，这就是简单工厂模式的应用。</p>
<p>本章视图用UML和模式的语言来解释女娲的做法。首先，在这个造人的思想里面，有几个重要角色：女娲本身、抽象的人的概念和女娲所造出来的具体的人。</p>

* 女娲是一个工厂类，也就是简单工厂模式的核心角色。
* 具体的一个个的人，是简单工厂模式里的具体产品角色。
* 抽象的人便是最早只存在于女娲头脑里的一个想法。

<p>女娲按照这个想法造出来的一个一个具体的人就都符合这个抽象的人的定义。即，这个抽象的想法规定了所有具体的人必须具有的接口。</p>
<p>女娲抟土造人的UML类图如下：</p>

<img src="./image/12.08.001.svg"/>

## 第13章 工厂方法（Factory Method）模式

<p></p>
<p></p>
<p></p>

### 13.1 引言

<p></p>
<p></p>

### 13.2 工厂方法模式的结构



### 13.3 工厂方法模式在农场系统中的实现



### 13.4 关于工厂方法模式的实现



### 13.5 Java语言中工厂方法模式的例子



### 13.6 工厂方法模式与其他模式的关系



### 13.7 女娲举绳造人



### 13.8 其他的例子



## 第14章 抽象工厂（Abstract Factory）模式



### 14.1 引言



### 14.2 问题



### 14.3 抽象工厂模式的结构



### 14.4 在什么情形下应当使用抽象工厂模式



### 14.5 抽象工厂模式在农场系统中的实现



### 14.6 抽象工厂模式的另一个例子



### 14.7 “开 - 闭”原则



### 14.8 相关的模式与模式的实现



### 14.9 女娲造万物的故事



### 14.10 附录：JavaAWT的Peer架构与抽象工厂模式



## 第15章 单例（Singleton）模式



### 15.1 引言



### 15.2 单例模式的结构



### 15.3 在什么情况下使用单例模式



### 15.4 单例类的状态



### 15.5 一个实用的例子：属性管理器



### 15.6 Java语言中的单例模式



### 15.7 专题：不完全的单例类



### 15.8 相关模式



### 15.9 附录：双重检查成例的研究



### 15.10 给读者的一点建议



## 第16章 专题：单例模式与MX记录



### 16.1 问题与解决方案



### 16.2 目录服务与MX记录



### 16.3 JNDI架构介绍



### 16.4 如何使用JNDI编程



### 16.5 系统设计



### 16.6 讨论



## 第17章 专题：多例（Multiton）模式与多语言支持



### 17.1 引言



### 17.2 多例模式



### 17.3 多语言项目的设计



## 第18章 专题：序列键生成器与单例及多例模式



### 18.1 问题



### 18.2 将单例模式应用到系统设计中



### 18.3 想多例模式应用到系统设计中



### 18.4 讨论



## 第19章 建造（Builder）模式



### 19.1 引言



### 19.2 建造模式的结构



### 19.3 建造模式的活动序列



### 19.4 建造模式的实现



### 19.5 众神造人的神话故事



### 19.6 JavaMail中的建造模式



### 19.7 一个发送邮件的例子



### 19.8 在什么情况下使用建造模式



### 19.9 建造模式与其他模式的关系



## 第20章 原始模型（Prototype）模式



### 20.1 引言



### 20.2 变量、对象以及对象的引用



### 20.3 Java对象的复制



### 20.4 原始模型模式的结构



### 20.5 模式的实现：深复制和浅复制



### 20.6 孙大圣的身外身法术



### 20.7 在什么情况下使用原始模型模式



### 20.8 原始模型模式的优点和缺点



### 20.9 原始模型模式与其他模式的关系



## 第21章 专题：JavaBean的“冷藏”和“解冻”



### 21.1 什么是“冷藏”和“解冻”



### 21.2 什么可以“冷藏”



### 21.3 Beans.instantiate()方法



### 21.4 怎样在JSP中使用Beans.instantiate()方法



### 21.5 与装饰模式的关系



# 第四部分



## 第22章 适配器（Adapter）模式



### 22.1 引言



### 22.2 类的适配器模式的结构



### 22.3 类的适配器模式的效果



### 22.4 对象的适配器模式的结构



### 22.5 在什么情况下使用适配器模式



### 22.6 Iterator与Enumeration



### 22.7 利用适配器模式指方为圆



### 22.8 适配器模式在架构层次上的应用



### 22.9 关于模式实现的讨论



### 22.10 适配器模式与相关的模式



## 第23章 缺省适配（Default Adapter）模式



### 23.1 鲁智深的故事



### 23.2 WindowAdapter是缺省适配模式



### 23.3 模式的结构



### 23.4 在什么情况下使用本模式



### 23.5 模式的实现



### 23.6 J2SE中的缺省适配模式



### 23.7 一个例子



## 第24章 专题：XMLProperties与适配器模式



### 24.1 引言



### 24.2 SAX2浏览器



### 24.3 开始XMLProperties项目



## 第25章 合成（Composite）模式



### 25.1 对象的树结构



### 25.2 介绍合成模式



### 25.3 安全式和透明式的合成模式



### 25.4 安全式的合成模式的结构



### 25.5 透明式的合成模式的结构



### 25.6 合成模式的实现



### 25.7 道士的故事



### 25.8 一个绘图的例子



### 25.9 AWT库中的例子



### 25.10 合成模式与其他模式的关系



## 第26章 装饰（Decorator）模式



### 26.1 引言



### 26.2 装饰模式的结构



### 26.3 装饰模式应当在什么情况下使用



### 26.4 孙大圣的故事



### 26.5 使用装饰模式的优点和缺点



### 26.6 模式实现的讨论



### 26.7 装饰模式与其他模式的关系



### 26.8 实例：GrepReader



### 26.9 一个例子：发票系统



### 26.10 附录：关于适配器模式与装饰模式的对话



## 第27章 专题：设计模式在Java I/O库中的应用



### 27.1 引言



### 27.2 Java I/O库的设计原则



### 27.3 装饰模式的应用



### 27.4 半透明的装饰模式



### 27.5 适配器模式的应用



### 27.6 从byte流到char流的适配



## 第28章 代理（Proxy）模式



### 28.1 引言



### 28.2 代理的种类



### 28.3 代理模式的结构



### 28.4 代理模式的时序



### 28.5 Java 2.0对代理模式的支持



### 28.6 高老庄悟空降八戒



### 28.7 代理模式的优点和缺点



### 28.8 代理模式的实现



### 28.9 代理模式与其他模式的关系



## 第29章 专题：智能引用代理



### 29.1 问题



### 29.2 系统设计



### 29.3 系统的时序



### 29.4 系统的源代码



## 第30章 专题：虚拟代理的例子



### 30.1 问题



### 30.2 系统的要求



### 30.3 系统的设计



### 30.4 系统的时序



### 30.5 系统的源代码



## 第31章 享元模式（Flyweight Pattern）



### 31.1 引言



### 31.2 单纯享元模式的结构



### 31.3 复合享元模式的结构



### 31.4 模式的实现



### 31.5 一个咖啡摊的例子



### 31.6 咖啡屋的例子



### 31.7 享元模式应当在什么情况下使用



### 31.8 从代码重构的角度看享元模式



### 31.9 享元模式的优点和缺点



### 31.10 相关的模式



## 第32章 门面（Facade）模式



### 32.1 引言



### 32.2 门面模式的结构



### 32.3 门面模式的实现



### 32.4 在什么情况下使用门面模式



### 32.5 迪米特法则（LoD）



### 32.6 一个例子



### 32.7 使用门面模式的设计



### 32.8 Session门面模式



## 第33章 桥梁（Bridge）模式



### 33.1 引言



### 33.2 桥梁模式的结构



### 33.3 Java语言中的Peer架构



### 33.4 驱动器和JDBC驱动器



### 33.5 从重构的角度考察



### 33.6 桥梁模式和其他模式的关系



### 33.7 八戒“转世投胎”的故事



### 33.8 关于桥梁模式的实现



### 33.9 在什么情况下应当使用桥梁模式



# 第五部分



## 第34章 不变（Immutable）模式



### 34.1 引言



### 34.2 不变模式的结构和实现



### 34.3 不变模式在Java语言中的应用



### 34.4 不变模式的优点和缺点



### 34.5 不变模式与享元模式的关系



### 34.6 一个例子：复数类



## 第35章 策略（Strategy）模式



### 35.1 引言



### 35.2 模式的实现



### 35.3 Java语言内部的例子



### 35.4 排序策略系统



### 35.5 一个例子：图书折扣的计算



### 35.6 在什么情况下应当使用策略模式



### 35.7 策略模式的优点和缺点



### 35.8 策略模式与其他模式的关系



### 35.9 设计原则的讨论



### 35.10 诸葛亮的锦囊妙计



## 第36章 模板方法（Template Method）模式



### 36.1 引言



### 36.2 模板方法模式的结构



### 36.3 “好莱坞原则”



### 36.4 一个例子



### 36.5 继承作为复用的工具



### 36.6 Java语言里面使用过的模板方法模式



### 36.7 模板方法模式中的方法



### 36.8 模板方法模式在代码重构中的应用



### 36.9 重构的原则



### 36.10 西天取经的八十一难



## 第37章 专题：Servlet技术中的模式



### 37.1 Servlet技术介绍



### 37.2 模板方法模式的使用



### 37.3 观察者模式的应用



## 第38章 观察者（Observer）模式



### 38.1 引言



### 38.2 观察者模式的结构



### 38.3 另一种实现方案



### 38.4 Java语言提供的对观察者模式的支持



### 38.5 菩萨的守瓶龟



### 38.6 Java中的DEM事件机制



### 38.7 观察者模式与其他模式的关系



## 第39章 专题：观察者模式与AWT中的事件处理



### 39.1 引言



### 39.2 DEM的结构



## 第40章 专题：观察者热模式与SAX2浏览器



### 40.1 引言



### 40.2 SAX2是怎么工作的



### 40.3 ContentHandler接口



### 40.4 怎样实现ContentHandler接口



### 40.5 怎样使用ContentHandler



### 40.6 缺省适配模式与DefaultHandler



### 40.7 简单工厂模式的应用



## 第41章 专题：观察者模式与Swing定时器



### 41.1 为什么需要定时器



### 41.2 Utility定时器与Swing定时器的区别



### 41.3 使用Swing定时器的方法



### 41.4 观察者模式的应用



### 41.5 单例模式的应用



## 第42章 专题：MVC模式与用户输入数据检查



### 42.1 什么是MVC模式



### 42.2 MVC是架构模式



### 42.3 MVC模式在J2EE技术中的应用



### 42.4 从代码重构的角度查看



### 42.5 用户输入检查与MVC模式



### 42.6 SQL注射



## 第43章 迭代子（Iterator）模式



### 43.1 引言



### 43.2 迭代子模式的结构



### 43.3 迭代子模式的实现



### 43.4 迭代子模式的优点和缺点



### 43.5 一个例子



### 43.6 迭代子模式与其他模式的关系



## 第44章 专题：Java对迭代子模式的支持



### 44.1 Java聚集



### 44.2 Java聚集中的迭代子



### 44.3 java.util.Iterator接口



### 44.4 Java迭代子接口ListIterator



### 44.5 Enumeration与Iterator



### 44.6 其他相关模式



## 第45章 责任链（Chain of Responsibility）模式



### 45.1 从击鼓传花谈起



### 45.2 责任链模式的结构



### 45.3 纯的与不纯的责任链模式



### 45.4 Java 1.0版本的AWT事件处理机制



### 45.5 『红楼梦』中击鼓传花的故事



### 45.6 Java系统的解



### 45.7 责任链模式的实现



### 45.8 对象的树结构



### 45.9 DHTML中的事件处理



### 45.10 责任链模式与其他模式的关系



## 第46章 专题：定时器与击鼓传花



### 46.1 线程



### 46.2 定时器



### 46.3 击鼓传花



## 第47章 命令（Command）模式



### 47.1 引言



### 47.2 命令模式的结构



### 47.3 玉帝传美猴王上天



### 47.4 Java语言内的例子：AWT的事件处理



### 47.5 一个例子：创世纪系统



### 47.6 一个例子：AudioPlayer系统



### 47.7 增加宏命令功能



### 47.8 模式的实现



### 47.9 在什么情况下应当使用命令模式



### 47.10 使用命令模式的优点和缺点



### 47.10 命令模式与其他模式的关系



## 第48章 专题：Swing库中的命令撤销和恢复



### 48.1 在视窗系统中使用命令模式



### 48.2 Swing的基本撤销功能



### 48.3 一休论禅的文字框



## 第49章 备忘录（Memento）模式



### 49.1 备忘录模式的结构



### 49.2 备忘录模式的白箱实现



### 49.3 双重接口及其在Java语言中的实现



### 49.4 备忘录模式的黑箱实现



### 49.5 责任人角色的增强



### 49.6 备忘录模式与多重检查点



### 49.7 “自述历史”模式



### 49.8 “假如”协议模式



### 49.9 备忘录模式与其他模式的关系



### 49.10 备忘录模式的应用



### 49.11 使用备忘录模式的优点和缺点



### 49.12 观世音甘泉活树的故事



## 第50章 状态（State）模式



### 50.1 引言



### 50.2 状态模式的结构



### 50.3 曾侯乙编钟的描述



### 50.4 状态模式的效果



### 50.5 在什么情况下使用状态模式



### 50.6 关于模式实现的讨论



### 50.7 一个状态模式的应用例子：TCP



### 50.8 状态模式在绘图软件中的应用



### 50.9 用户登录子系统



### 50.10 状态模式与策略模式的区别



## 第51章 专题：崂山道士与状态模式



### 51.1 有状态的墙



### 51.2 异常逻辑



### 51.3 从代码重构的角度考察



## 第52章 专题：单分派和多分派



### 52.1 分派的概念



### 52.2 双重分派



### 52.3 未来的Java语言



## 第53章 访问者（Visitor）模式



### 53.1 引言



### 53.2 访问者模式的结构



### 53.3 系统的时序图



### 53.4 在什么情况下应当使用访问者模式



### 53.5 使用访问者模式的优点和缺点



### 53.6 访问者模式的实现



### 53.7 电脑专卖系统：问题与对象



### 53.8 电脑专卖系统的访问者模式设计



### 53.9 与访问者模式有关的模式



## 第54章 解释器（Interpreter）模式



### 54.1 引言



### 54.2 解释器模式的结构



### 54.3 一个示意性的实现



### 54.4 有关模式



## 第55章 调停者（Mediator）模式



### 55.1 引言



### 55.2 调停者模式的结构



### 55.3 调停者模式的实现



### 55.4 迪米特法则（LoD）



### 55.5 调停者模式的优点和缺点



### 55.6 调停者模式的使用条件



### 55.7 与调停者模式有关的模式



# 附录



## 附录A 设计模式一览表



### A.1 创建模式



### A.2 结构模式



### A.3 行为模式



## 附录B UML图标及Java实现



### 一览表



## 附录C 中英术语对照表


