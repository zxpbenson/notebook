# 目录

<table>
<caption>Overview</caption>
<tr><th>部分</th><th>大章节</th><th>小章节</th></tr>

<tr>
<td rowspan=14>第一部分</td>
<td rowspan=7>第1章 模式的简史和形而上学</td>
<td>1.1 模式是什么</td>
</tr>
<tr><td>1.2 软件模式的简史</td></tr>
<tr><td>1.3 模式的起源</td></tr>
<tr><td>1.4 与道家思想的关系</td></tr>
<tr><td>1.5 软件的永恒之道</td></tr>
<tr><td>1.6 模式的要素</td></tr>
<tr><td>1.7 本书讲解模式的格式</td></tr>

<tr>
<td rowspan=7>第2章 统一建模语言UML简介</td>
<td>2.1 建造世界贸易中心</td>
</tr>
<tr><td>2.2 什么是UML</td></tr>
<tr><td>2.3 UML包括什么</td></tr>
<tr><td>2.4 类图</td></tr>
<tr><td>2.5 时序图</td></tr>
<tr><td>2.6 状态图</td></tr>
<tr><td>2.7 UML及建模的工具</td></tr>

<tr>
<td rowspan=42>第二部分</td>
<td rowspan=3>第3章 软件的可维护性与可复用性</td>
<td>3.1 软件系统的可维护性</td>
</tr>
<tr><td>3.2 系统的可复用性</td></tr>
<tr><td>3.3 老子论“不武”</td></tr>

<tr>
<td rowspan=6>第4章 “开 - 闭”原则（OCP）</td>
<td>4.1 什么是“开 - 闭”原则</td>
</tr>
<tr><td>4.2 怎样做到“开 - 闭”原则</td></tr>
<tr><td>4.3 与其他设计原则的关系</td></tr>
<tr><td>4.4 策略模式对“开 - 闭”原则的支持</td></tr>
<tr><td>4.5 在其他设计模式中的体现</td></tr>
<tr><td>4.6 一个重构做法的讨论</td></tr>

<tr>
<td rowspan=3>第5章 专题：Java语言的接口</td>
<td>5.1 什么是接口</td>
</tr>
<tr><td>5.2 为什么使用接口</td></tr>
<tr><td>5.3 Java接口常见的用法</td></tr>

<tr>
<td rowspan=4>第6章 专题：抽象类</td>
<td>6.1 什么是抽象类</td>
</tr>
<tr><td>6.2 抽象类的用途</td></tr>
<tr><td>6.3 基于抽象类的模式和原则</td></tr>
<tr><td>6.4 什么时候才应当使用继承复用</td></tr>

<tr>
<td rowspan=5>第7章 里氏代换原则（LSP）</td>
<td>7.1 美猴王的智慧</td>
</tr>
<tr><td>7.2 什么是里氏代换原则</td></tr>
<tr><td>7.3 里氏代换原则在设计模式中的体现</td></tr>
<tr><td>7.4 墨子论“取譬”</td></tr>
<tr><td>7.5 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=8>第8章 依赖倒转原则（DIP）</td>
<td>8.1 为何而“倒转”</td>
</tr>
<tr><td>8.2 复用与可维护性的倒转</td></tr>
<tr><td>8.3 依赖倒转原则</td></tr>
<tr><td>8.4 怎样做到依赖倒转原则</td></tr>
<tr><td>8.5 Java对抽象类型的支持</td></tr>
<tr><td>8.6 一个例子：账号、账号的种类和账号的状态</td></tr>
<tr><td>8.7 墨子论“取周”</td></tr>
<tr><td>8.8 依赖倒转原则的优缺点</td></tr>

<tr>
<td rowspan=3>第9章 接口隔离原则（ISP）</td>
<td>9.1 什么是接口隔离原则</td>
</tr>
<tr><td>9.2 一个角色隔离原则的例子</td></tr>
<tr><td>9.3 定制服务的例子</td></tr>

<tr>
<td rowspan=3>第10章 合成/聚合复用原则（CARP）</td>
<td>10.1 合成和聚合的区别</td>
</tr>
<tr><td>10.2 复用的基本种类</td></tr>
<tr><td>10.3 从代码重构的角度理解</td></tr>

<tr>
<td rowspan=7>第11章 迪米特法则（LoD）</td>
<td>11.1 迪米特法则的各种表述</td>
</tr>
<tr><td>11.2 狭义的迪米特法则</td></tr>
<tr><td>11.3 迪米特法则与设计模式</td></tr>
<tr><td>11.4 广义的迪米特法则</td></tr>
<tr><td>11.5 广义迪米特法则在类的设计上的体现</td></tr>
<tr><td>11.6 广义迪米特法则在代码层次上的实现</td></tr>
<tr><td>11.7 老子论“圣人之治”</td></tr>

<tr>
<td rowspan=72>第三部分</td>
<td rowspan=8>第12章 简单工厂（Simple Factory）模式</td>
<td>12.1 工厂模式的几种形态</td>
</tr>
<tr><td>12.2 简单工厂模式的引进</td></tr>
<tr><td>12.3 简单工厂模式的结构</td></tr>
<tr><td>12.4 简单工厂模式的实现</td></tr>
<tr><td>12.5 简单工厂模式与其他模式的关系</td></tr>
<tr><td>12.6 简单工厂模式的优点和缺点</td></tr>
<tr><td>12.7 简单工厂模式在Java中的应用</td></tr>
<tr><td>12.8 女娲抟(tuan2)土造人</td></tr>


<tr>
<td rowspan=8>第13章 工厂方法（Factory Method）模式</td>
<td>13.1 引言</td>
</tr>
<tr><td>13.2 工厂方法模式的结构</td></tr>
<tr><td>13.3 工厂方法模式在农场系统中的实现</td></tr>
<tr><td>13.4 关于工厂方法模式的实现</td></tr>
<tr><td>13.5 Java语言中工厂方法模式的例子</td></tr>
<tr><td>13.6 工厂方法模式与其他模式的关系</td></tr>
<tr><td>13.7 女娲举绳造人</td></tr>
<tr><td>13.8 其他的例子</td></tr>

<tr>
<td rowspan=10>第14章 抽象工厂（Abstract Factory）模式</td>
<td>14.1 引言</td>
</tr>
<tr><td>14.2 问题</td></tr>
<tr><td>14.3 抽象工厂模式的结构</td></tr>
<tr><td>14.4 在什么情形下应当使用抽象工厂模式</td></tr>
<tr><td>14.5 抽象工厂模式在农场系统中的实现</td></tr>
<tr><td>14.6 抽象工厂模式的另一个例子</td></tr>
<tr><td>14.7 “开 - 闭”原则</td></tr>
<tr><td>14.8 相关的模式与模式的实现</td></tr>
<tr><td>14.9 女娲造万物的故事</td></tr>
<tr><td>14.10 附录：JavaAWT的Peer架构与抽象工厂模式</td></tr>

<tr>
<td rowspan=10>第15章 单例（Singleton）模式</td>
<td>15.1 引言</td>
</tr>
<tr><td>15.2 单例模式的结构</td></tr>
<tr><td>15.3 在什么情况下使用单例模式</td></tr>
<tr><td>15.4 单例类的状态</td></tr>
<tr><td>15.5 一个实用的例子：属性管理器</td></tr>
<tr><td>15.6 Java语言中的单例模式</td></tr>
<tr><td>15.7 专题：不完全的单例类</td></tr>
<tr><td>15.8 相关模式</td></tr>
<tr><td>15.9 附录：双重检查成例的研究</td></tr>
<tr><td>15.10 给读者的一点建议</td></tr>

<tr>
<td rowspan=6>第16章 专题：单例模式与MX记录</td>
<td>16.1 问题与解决方案</td>
</tr>
<tr><td>16.2 目录服务与MX记录</td></tr>
<tr><td>16.3 JNDI架构介绍</td></tr>
<tr><td>16.4 如何使用JNDI编程</td></tr>
<tr><td>16.5 系统设计</td></tr>
<tr><td>16.6 讨论</td></tr>

<tr>
<td rowspan=3>第17章 专题：多例（Multiton）模式与多语言支持</td>
<td>17.1 引言</td>
</tr>
<tr><td>17.2 多例模式</td></tr>
<tr><td>17.3 多语言项目的设计</td></tr>

<tr>
<td rowspan=4>第18章 专题：序列键生成器与单例及多例模式</td>
<td>18.1 问题</td>
</tr>
<tr><td>18.2 将单例模式应用到系统设计中</td></tr>
<tr><td>18.3 想多例模式应用到系统设计中</td></tr>
<tr><td>18.4 讨论</td></tr>

<tr>
<td rowspan=9>第19章 建造（Builder）模式</td>
<td>19.1 引言</td>
</tr>
<tr><td>19.2 建造模式的结构</td></tr>
<tr><td>19.3 建造模式的活动序列</td></tr>
<tr><td>19.4 建造模式的实现</td></tr>
<tr><td>19.5 众神造人的神话故事</td></tr>
<tr><td>19.6 JavaMail中的建造模式</td></tr>
<tr><td>19.7 一个发送邮件的例子</td></tr>
<tr><td>19.8 在什么情况下使用建造模式</td></tr>
<tr><td>19.9 建造模式与其他模式的关系</td></tr>

<tr>
<td rowspan=9>第20章 原始模型（Prototype）模式</td>
<td>20.1 引言</td>
</tr>
<tr><td>20.2 变量、对象以及对象的引用</td></tr>
<tr><td>20.3 Java对象的复制</td></tr>
<tr><td>20.4 原始模型模式的结构</td></tr>
<tr><td>20.5 模式的实现：深复制和浅复制</td></tr>
<tr><td>20.6 孙大圣的身外身法术</td></tr>
<tr><td>20.7 在什么情况下使用原始模型模式</td></tr>
<tr><td>20.8 原始模型模式的优点和缺点</td></tr>
<tr><td>20.9 原始模型模式与其他模式的关系</td></tr>

<tr>
<td rowspan=5>第21章 专题：JavaBean的“冷藏”和“解冻”</td>
<td>21.1 什么是“冷藏”和“解冻”</td>
</tr>
<tr><td>21.2 什么可以“冷藏”</td></tr>
<tr><td>21.3 Beans.instantiate()方法</td></tr>
<tr><td>21.4 怎样在JSP中使用Beans.instantiate()方法</td></tr>
<tr><td>21.5 与装饰模式的关系</td></tr>

<tr>
<td rowspan=91>第四部分</td>
<td rowspan=10>第22章 适配器（Adapter）模式</td>
<td>22.1 引言</td>
</tr>
<tr><td>22.2 类的适配器模式的结构</td></tr>
<tr><td>22.3 类的适配器模式的效果</td></tr>
<tr><td>22.4 对象的适配器模式的结构</td></tr>
<tr><td>22.5 在什么情况下使用适配器模式</td></tr>
<tr><td>22.6 Iterator与Enumeration</td></tr>
<tr><td>22.7 利用适配器模式指方为圆</td></tr>
<tr><td>22.8 适配器模式在架构层次上的应用</td></tr>
<tr><td>22.9 关于模式实现的讨论</td></tr>
<tr><td>22.10 适配器模式与相关的模式</td></tr>

<tr>
<td rowspan=7>第23章 缺省适配（Default Adapter）模式</td>
<td>23.1 鲁智深的故事</td>
</tr>
<tr><td>23.2 WindowAdapter是缺省适配模式</td></tr>
<tr><td>23.3 模式的结构</td></tr>
<tr><td>23.4 在什么情况下使用本模式</td></tr>
<tr><td>23.5 模式的实现</td></tr>
<tr><td>23.6 J2SE中的缺省适配模式</td></tr>
<tr><td>23.7 一个例子</td></tr>

<tr>
<td rowspan=3>第24章 专题：XMLProperties与适配器模式</td>
<td>24.1 引言</td>
</tr>
<tr><td>24.2 SAX2浏览器</td></tr>
<tr><td>24.3 开始XMLProperties项目</td></tr>

<tr>
<td rowspan=10>第25章 合成（Composite）模式</td>
<td>25.1 对象的树结构</td>
</tr>
<tr><td>25.2 介绍合成模式</td></tr>
<tr><td>25.3 安全式和透明式的合成模式</td></tr>
<tr><td>25.4 安全式的合成模式的结构</td></tr>
<tr><td>25.5 透明式的合成模式的结构</td></tr>
<tr><td>25.6 合成模式的实现</td></tr>
<tr><td>25.7 道士的故事</td></tr>
<tr><td>25.8 一个绘图的例子</td></tr>
<tr><td>25.9 AWT库中的例子</td></tr>
<tr><td>25.10 合成模式与其他模式的关系</td></tr>

<tr>
<td rowspan=10>第26章 装饰（Decorator）模式</td>
<td>26.1 引言</td>
</tr>
<tr><td>26.2 装饰模式的结构</td></tr>
<tr><td>26.3 装饰模式应当在什么情况下使用</td></tr>
<tr><td>26.4 孙大圣的故事</td></tr>
<tr><td>26.5 使用装饰模式的优点和缺点</td></tr>
<tr><td>26.6 模式实现的讨论</td></tr>
<tr><td>26.7 装饰模式与其他模式的关系</td></tr>
<tr><td>26.8 实例：GrepReader</td></tr>
<tr><td>26.9 一个例子：发票系统</td></tr>
<tr><td>26.10 附录：关于适配器模式与装饰模式的对话</td></tr>

<tr>
<td rowspan=6>第27章 专题：设计模式在Java I/O库中的应用</td>
<td>27.1 引言</td>
</tr>
<tr><td>27.2 Java I/O库的设计原则</td></tr>
<tr><td>27.3 装饰模式的应用</td></tr>
<tr><td>27.4 半透明的装饰模式</td></tr>
<tr><td>27.5 适配器模式的应用</td></tr>
<tr><td>27.6 从byte流到char流的适配</td></tr>

<tr>
<td rowspan=9>第28章 代理（Proxy）模式</td>
<td>28.1 引言</td>
</tr>
<tr><td>28.2 代理的种类</td></tr>
<tr><td>28.3 代理模式的结构</td></tr>
<tr><td>28.4 代理模式的时序</td></tr>
<tr><td>28.5 Java 2.0对代理模式的支持</td></tr>
<tr><td>28.6 高老庄悟空降八戒</td></tr>
<tr><td>28.7 代理模式的优点和缺点</td></tr>
<tr><td>28.8 代理模式的实现</td></tr>
<tr><td>28.9 代理模式与其他模式的关系</td></tr>

<tr>
<td rowspan=4>第29章 专题：智能引用代理</td>
<td>29.1 问题</td>
</tr>
<tr><td>29.2 系统设计</td></tr>
<tr><td>29.3 系统的时序</td></tr>
<tr><td>29.4 系统的源代码</td></tr>

<tr>
<td rowspan=5>第30章 专题：虚拟代理的例子</td>
<td>30.1 问题</td>
</tr>
<tr><td>30.2 系统的要求</td></tr>
<tr><td>30.3 系统的设计</td></tr>
<tr><td>30.4 系统的时序</td></tr>
<tr><td>30.5 系统的源代码</td></tr>

<tr>
<td rowspan=10>第31章 享元模式（Flyweight Pattern）</td>
<td>31.1 引言</td>
</tr>
<tr><td>31.2 单纯享元模式的结构</td></tr>
<tr><td>31.3 复合享元模式的结构</td></tr>
<tr><td>31.4 模式的实现</td></tr>
<tr><td>31.5 一个咖啡摊的例子</td></tr>
<tr><td>31.6 咖啡屋的例子</td></tr>
<tr><td>31.7 享元模式应当在什么情况下使用</td></tr>
<tr><td>31.8 从代码重构的角度看享元模式</td></tr>
<tr><td>31.9 享元模式的优点和缺点</td></tr>
<tr><td>31.10 相关的模式</td></tr>

<tr>
<td rowspan=8>第32章 门面（Facade）模式</td>
<td>32.1 引言</td>
</tr>
<tr><td>32.2 门面模式的结构</td></tr>
<tr><td>32.3 门面模式的实现</td></tr>
<tr><td>32.4 在什么情况下使用门面模式</td></tr>
<tr><td>32.5 迪米特法则（LoD）</td></tr>
<tr><td>32.6 一个例子</td></tr>
<tr><td>32.7 使用门面模式的设计</td></tr>
<tr><td>32.8 Session门面模式</td></tr>

<tr>
<td rowspan=9>第33章 桥梁（Bridge）模式</td>
<td>33.1 引言</td>
</tr>
<tr><td>33.2 桥梁模式的结构</td></tr>
<tr><td>33.3 Java语言中的Peer架构</td></tr>
<tr><td>33.4 驱动器和JDBC驱动器</td></tr>
<tr><td>33.5 从重构的角度考察</td></tr>
<tr><td>33.6 桥梁模式和其他模式的关系</td></tr>
<tr><td>33.7 八戒“转世投胎”的故事</td></tr>
<tr><td>33.8 关于桥梁模式的实现</td></tr>
<tr><td>33.9 在什么情况下应当使用桥梁模式</td></tr>

<tr>
<td rowspan=143>第五部分</td>
<td rowspan=6>第34章 不变（Immutable）模式</td>
<td>34.1 引言</td>
</tr>
<tr><td>34.2 不变模式的结构和实现</td></tr>
<tr><td>34.3 不变模式在Java语言中的应用</td></tr>
<tr><td>34.4 不变模式的优点和缺点</td></tr>
<tr><td>34.5 不变模式与享元模式的关系</td></tr>
<tr><td>34.6 一个例子：复数类</td></tr>

<tr>
<td rowspan=10>第35章 策略（Strategy）模式</td>
<td>35.1 引言</td>
</tr>
<tr><td>35.2 模式的实现</td></tr>
<tr><td>35.3 Java语言内部的例子</td></tr>
<tr><td>35.4 排序策略系统</td></tr>
<tr><td>35.5 一个例子：图书折扣的计算</td></tr>
<tr><td>35.6 在什么情况下应当使用策略模式</td></tr>
<tr><td>35.7 策略模式的优点和缺点</td></tr>
<tr><td>35.8 策略模式与其他模式的关系</td></tr>
<tr><td>35.9 设计原则的讨论</td></tr>
<tr><td>35.10 诸葛亮的锦囊妙计</td></tr>

<tr>
<td rowspan=10>第36章 模板方法（Template Method）模式</td>
<td>36.1 引言</td>
</tr>
<tr><td>36.2 模板方法模式的结构</td></tr>
<tr><td>36.3 “好莱坞原则”</td></tr>
<tr><td>36.4 一个例子</td></tr>
<tr><td>36.5 继承作为复用的工具</td></tr>
<tr><td>36.6 Java语言里面使用过的模板方法模式</td></tr>
<tr><td>36.7 模板方法模式中的方法</td></tr>
<tr><td>36.8 模板方法模式在代码重构中的应用</td></tr>
<tr><td>36.9 重构的原则</td></tr>
<tr><td>36.10 西天取经的八十一难</td></tr>

<tr>
<td rowspan=3>第37章 专题：Servlet技术中的模式</td>
<td>37.1 Servlet技术介绍</td>
</tr>
<tr><td>37.2 模板方法模式的使用</td></tr>
<tr><td>37.3 观察者模式的应用</td></tr>

<tr>
<td rowspan=7>第38章 观察者（Observer）模式</td>
<td>38.1 引言</td>
</tr>
<tr><td>38.2 观察者模式的结构</td></tr>
<tr><td>38.3 另一种实现方案</td></tr>
<tr><td>38.4 Java语言提供的对观察者模式的支持</td></tr>
<tr><td>38.5 菩萨的守瓶龟</td></tr>
<tr><td>38.6 Java中的DEM事件机制</td></tr>
<tr><td>38.7 观察者模式与其他模式的关系</td></tr>

<tr>
<td rowspan=2>第39章 专题：观察者模式与AWT中的事件处理</td>
<td>39.1 引言</td>
</tr>
<tr><td>39.2 DEM的结构</td></tr>

<tr>
<td rowspan=7>第40章 专题：观察者热模式与SAX2浏览器</td>
<td>40.1 引言</td>
</tr>
<tr><td>40.2 SAX2是怎么工作的</td></tr>
<tr><td>40.3 ContentHandler接口</td></tr>
<tr><td>40.4 怎样实现ContentHandler接口</td></tr>
<tr><td>40.5 怎样使用ContentHandler</td></tr>
<tr><td>40.6 缺省适配模式与DefaultHandler</td></tr>
<tr><td>40.7 简单工厂模式的应用</td></tr>

<tr>
<td rowspan=5>第41章 专题：观察者模式与Swing定时器</td>
<td>41.1 为什么需要定时器</td>
</tr>
<tr><td>41.2 Utility定时器与Swing定时器的区别</td></tr>
<tr><td>41.3 使用Swing定时器的方法</td></tr>
<tr><td>41.4 观察者模式的应用</td></tr>
<tr><td>41.5 单例模式的应用</td></tr>

<tr>
<td rowspan=6>第42章 专题：MVC模式与用户输入数据检查</td>
<td>42.1 什么是MVC模式</td>
</tr>
<tr><td>42.2 MVC是架构模式</td></tr>
<tr><td>42.3 MVC模式在J2EE技术中的应用</td></tr>
<tr><td>42.4 从代码重构的角度查看</td></tr>
<tr><td>42.5 用户输入检查与MVC模式</td></tr>
<tr><td>42.6 SQL注射</td></tr>

<tr>
<td rowspan=6>第43章 迭代子（Iterator）模式</td>
<td>43.1 引言</td>
</tr>
<tr><td>43.2 迭代子模式的结构</td></tr>
<tr><td>43.3 迭代子模式的实现</td></tr>
<tr><td>43.4 迭代子模式的优点和缺点</td></tr>
<tr><td>43.5 一个例子</td></tr>
<tr><td>43.6 迭代子模式与其他模式的关系</td></tr>


<tr>
<td rowspan=6>第44章 专题：Java对迭代子模式的支持</td>
<td>44.1 Java聚集</td>
</tr>
<tr><td>44.2 Java聚集中的迭代子</td></tr>
<tr><td>44.3 java.util.Iterator接口</td></tr>
<tr><td>44.4 Java迭代子接口ListIterator</td></tr>
<tr><td>44.5 Enumeration与Iterator</td></tr>
<tr><td>44.6 其他相关模式</td></tr>

<tr>
<td rowspan=10>第45章 责任链（Chain of Responsibility）模式</td>
<td>45.1 从击鼓传花谈起</td>
</tr>
<tr><td>45.2 责任链模式的结构</td></tr>
<tr><td>45.3 纯的与不纯的责任链模式</td></tr>
<tr><td>45.4 Java 1.0版本的AWT事件处理机制</td></tr>
<tr><td>45.5 『红楼梦』中击鼓传花的故事</td></tr>
<tr><td>45.6 Java系统的解</td></tr>
<tr><td>45.7 责任链模式的实现</td></tr>
<tr><td>45.8 对象的树结构</td></tr>
<tr><td>45.9 DHTML中的事件处理</td></tr>
<tr><td>45.10 责任链模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第46章 专题：定时器与击鼓传花</td>
<td>46.1 线程</td>
</tr>
<tr><td>46.2 定时器</td></tr>
<tr><td>46.3 击鼓传花</td></tr>

<tr>
<td rowspan=11>第47章 命令（Command）模式</td>
<td>47.1 引言</td>
</tr>
<tr><td>47.2 命令模式的结构</td></tr>
<tr><td>47.3 玉帝传美猴王上天</td></tr>
<tr><td>47.4 Java语言内的例子：AWT的事件处理</td></tr>
<tr><td>47.5 一个例子：创世纪系统</td></tr>
<tr><td>47.6 一个例子：AudioPlayer系统</td></tr>
<tr><td>47.7 增加宏命令功能</td></tr>
<tr><td>47.8 模式的实现</td></tr>
<tr><td>47.9 在什么情况下应当使用命令模式</td></tr>
<tr><td>47.10 使用命令模式的优点和缺点</td></tr>
<tr><td>47.10 命令模式与其他模式的关系</td></tr>

<tr>
<td rowspan=3>第48章 专题：Swing库中的命令撤销和恢复</td>
<td>48.1 在视窗系统中使用命令模式</td>
</tr>
<tr><td>48.2 Swing的基本撤销功能</td></tr>
<tr><td>48.3 一休论禅的文字框</td></tr>

<tr>
<td rowspan=12>第49章 备忘录（Memento）模式</td>
<td>49.1 备忘录模式的结构</td>
</tr>
<tr><td>49.2 备忘录模式的白箱实现</td></tr>
<tr><td>49.3 双重接口及其在Java语言中的实现</td></tr>
<tr><td>49.4 备忘录模式的黑箱实现</td></tr>
<tr><td>49.5 责任人角色的增强</td></tr>
<tr><td>49.6 备忘录模式与多重检查点</td></tr>
<tr><td>49.7 “自述历史”模式</td></tr>
<tr><td>49.8 “假如”协议模式</td></tr>
<tr><td>49.9 备忘录模式与其他模式的关系</td></tr>
<tr><td>49.10 备忘录模式的应用</td></tr>
<tr><td>49.11 使用备忘录模式的优点和缺点</td></tr>
<tr><td>49.12 观世音甘泉活树的故事</td></tr>

<tr>
<td rowspan=10>第50章 状态（State）模式</td>
<td>50.1 引言</td>
</tr>
<tr><td>50.2 状态模式的结构</td></tr>
<tr><td>50.3 曾侯乙编钟的描述</td></tr>
<tr><td>50.4 状态模式的效果</td></tr>
<tr><td>50.5 在什么情况下使用状态模式</td></tr>
<tr><td>50.6 关于模式实现的讨论</td></tr>
<tr><td>50.7 一个状态模式的应用例子：TCP</td></tr>
<tr><td>50.8 状态模式在绘图软件中的应用</td></tr>
<tr><td>50.9 用户登录子系统</td></tr>
<tr><td>50.10 状态模式与策略模式的区别</td></tr>

<tr>
<td rowspan=3>第51章 专题：崂山道士与状态模式</td>
<td>51.1 有状态的墙</td>
</tr>
<tr><td>51.2 异常逻辑</td></tr>
<tr><td>51.3 从代码重构的角度考察</td></tr>

<tr>
<td rowspan=3>第52章 专题：单分派和多分派</td>
<td>52.1 分派的概念</td>
</tr>
<tr><td>52.2 双重分派</td></tr>
<tr><td>52.3 未来的Java语言</td></tr>

<tr>
<td rowspan=9>第53章 访问者（Visitor）模式</td>
<td>53.1 引言</td>
</tr>
<tr><td>53.2 访问者模式的结构</td></tr>
<tr><td>53.3 系统的时序图</td></tr>
<tr><td>53.4 在什么情况下应当使用访问者模式</td></tr>
<tr><td>53.5 使用访问者模式的优点和缺点</td></tr>
<tr><td>53.6 访问者模式的实现</td></tr>
<tr><td>53.7 电脑专卖系统：问题与对象</td></tr>
<tr><td>53.8 电脑专卖系统的访问者模式设计</td></tr>
<tr><td>53.9 与访问者模式有关的模式</td></tr>

<tr>
<td rowspan=4>第54章 解释器（Interpreter）模式</td>
<td>54.1 引言</td>
</tr>
<tr><td>54.2 解释器模式的结构</td></tr>
<tr><td>54.3 一个示意性的实现</td></tr>
<tr><td>54.4 有关模式</td></tr>

<tr>
<td rowspan=7>第55章 调停者（Mediator）模式</td>
<td>55.1 引言</td>
</tr>
<tr><td>55.2 调停者模式的结构</td></tr>
<tr><td>55.3 调停者模式的实现</td></tr>
<tr><td>55.4 迪米特法则（LoD）</td></tr>
<tr><td>55.5 调停者模式的优点和缺点</td></tr>
<tr><td>55.6 调停者模式的使用条件</td></tr>
<tr><td>55.7 与调停者模式有关的模式</td></tr>

<tr>
<td rowspan=5>附录</td>
<td rowspan=3>附录A 设计模式一览表</td>
<td>A.1 创建模式</td>
</tr>
<tr><td>A.2 结构模式</td></tr>
<tr><td>A.3 行为模式</td></tr>

<tr>
<td rowspan=1>附录B UML图标及Java实现</td>
<td>一览表</td>
</tr>

<tr>
<td colspan=2>附录C 中英术语对照表</td>
</tr>
</table>

# 第一部分



## 第1章 模式的简史和形而上学



### 1.1 模式是什么



### 1.2 软件模式的简史



### 1.3 模式的起源



### 1.4 与道家思想的关系



### 1.5 软件的永恒之道



### 1.6 模式的要素



### 1.7 本书讲解模式的格式



## 第2章 统一建模语言UML简介



### 2.1 建造世界贸易中心



### 2.2 什么是UML



### 2.3 UML包括什么



### 2.4 类图



### 2.5 时序图



### 2.6 状态图



### 2.7 UML及建模的工具



# 第二部分



## 第3章 软件的可维护性与可复用性



### 3.1 软件系统的可维护性



### 3.2 系统的可复用性



### 3.3 老子论“不武”



## 第4章 “开 - 闭”原则（OCP）



### 4.1 什么是“开 - 闭”原则



### 4.2 怎样做到“开 - 闭”原则



### 4.3 与其他设计原则的关系



### 4.4 策略模式对“开 - 闭”原则的支持



### 4.5 在其他设计模式中的体现



### 4.6 一个重构做法的讨论



## 第5章 专题：Java语言的接口



### 5.1 什么是接口



### 5.2 为什么使用接口



### 5.3 Java接口常见的用法



## 第6章 专题：抽象类



### 6.1 什么是抽象类



### 6.2 抽象类的用途



### 6.3 基于抽象类的模式和原则



### 6.4 什么时候才应当使用继承复用



## 第7章 里氏代换原则（LSP）



### 7.1 美猴王的智慧



### 7.2 什么是里氏代换原则



### 7.3 里氏代换原则在设计模式中的体现



### 7.4 墨子论“取譬”



### 7.5 从代码重构的角度理解



## 第8章 依赖倒转原则（DIP）



### 8.1 为何而“倒转”



### 8.2 复用与可维护性的倒转



### 8.3 依赖倒转原则



### 8.4 怎样做到依赖倒转原则



### 8.5 Java对抽象类型的支持



### 8.6 一个例子：账号、账号的种类和账号的状态



### 8.7 墨子论“取周”



### 8.8 依赖倒转原则的优缺点



## 第9章 接口隔离原则（ISP）



### 9.1 什么是接口隔离原则



### 9.2 一个角色隔离原则的例子



### 9.3 定制服务的例子



## 第10章 合成/聚合复用原则（CARP）



### 10.1 合成和聚合的区别



### 10.2 复用的基本种类



### 10.3 从代码重构的角度理解



## 第11章 迪米特法则（LoD）



### 11.1 迪米特法则的各种表述



### 11.2 狭义的迪米特法则



### 11.3 迪米特法则与设计模式



### 11.4 广义的迪米特法则



### 11.5 广义迪米特法则在类的设计上的体现



### 11.6 广义迪米特法则在代码层次上的实现



### 11.7 老子论“圣人之治”



# 第三部分 创建模式

<p>创建模式（Createional Pattern）是对类的实例化过程的抽象化。</p>
<p>一些系统在创建对象时，需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。</p>
<p>创建模式描述了怎样构造和封装这些动态的决定。</p>

<table>
<caption>创建模式分两类</caption>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
<tr>
<td>类的创建模式</td>
<td>
使用继承关系把类的创建延迟到子类<br>
从而封装了客户端将得到哪些具体类的信息<br>
并且隐藏了这些类的实例是如何被创建和放在一起的
</td>
</tr>
<tr>
<td>对象的创建模式</td>
<td>
把对象的创建过程动态的委派给另一个对象<br>
从而动态的决定客户端将得到哪些具体类的实例<br>
以及这些类的实例是如何被创建和组合在一起的<br>
</td>
</tr>
</table>

<p>下面将介绍以下创建模式及专题：</p>

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 单例模式（专题：单例模式与MX记录）
* 多例模式（专题：序列键生成器与单例及多例模式）
* 建造模式
* 原始模型模式（专题：JavaBean的“冷藏”和“解冻”）

## 第12章 简单工厂（Simple Factory）模式

<p>简单工厂模式是类的创建模式，是由一个工厂对象决定创建出哪一种产品类的实例</p>

### 12.1 工厂模式的几种形态

* 简单工厂(Simple Factory)模式又叫静态工厂方法模式(Static Factory Method Pattern)
* 工厂方法(Factory Method)模式又叫多态工厂(Polymorphic Factory)模式或者虚拟构造子(Virtual Constructor)模式
* 抽象工厂(Abstract Factory)模式又叫工具箱(Kit or Toolkit)模式

<p>简单工厂模式是工厂方法模式的一个特殊实现。</p>

### 12.2 简单工厂模式的引进

<p>如下是一套完整的演示代码：</p>

<kbd>Fruit.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public interface Fruit {
    /*
     * 种植
     * */
    void plant();
    /*
    * 生长
    * */
    void grow();
    /*
     * 收货
     * */
    void harvest();
}
```
<kbd>Apple.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Apple implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Apple.class);

    private int treeAge;

    @Override
    public void plant() {
        LOG.info("Apple has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Apple is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Apple has benn harvested.");
    }

    public int getTreeAge() {
        return treeAge;
    }

    public void setTreeAge(int treeAge) {
        this.treeAge = treeAge;
    }
}
```

<kbd>Grape.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Grape implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Grape.class);

    private boolean seedless;

    @Override
    public void plant() {
        LOG.info("Grape has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Grape is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Grape has benn harvested.");
    }

    public boolean isSeedless() {
        return seedless;
    }

    public void setSeedless(boolean seedless) {
        this.seedless = seedless;
    }
}
```

<kbd>Strawberry.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Strawberry implements Fruit {

    private static final Logger LOG = LoggerFactory.getLogger(Strawberry.class);

    @Override
    public void plant() {
        LOG.info("Grape has benn planted.");
    }

    @Override
    public void grow() {
        LOG.info("Grape is growing...");
    }

    @Override
    public void harvest() {
        LOG.info("Grape has benn harvested.");
    }
}
```

<kbd>BadFruitException.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public class BadFruitException extends Exception {
    public BadFruitException(String message) {
        super(message);
    }
}
```

<kbd>FruitGardener.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

public class FruitGardener {
    public static Fruit factory(String which) throws BadFruitException {
        if ("apple".equalsIgnoreCase(which)) {
            return new Apple();
        } else if ("grape".equalsIgnoreCase(which)) {
            return new Grape();
        } else if ("strawberry".equalsIgnoreCase(which)) {
            return new Strawberry();
        } else {
            throw new BadFruitException("Bad fruit request");
        }
    }
}
```

<kbd>FruitGardenerTest.java</kbd>

```java
package com.benson.note.pij.construct.example1.simplefactory;

import junit.framework.TestCase;
import org.junit.Test;

public class FruitGardenerTest extends TestCase {

    @Test
    public void testFactory() {
        try {
            Fruit fruit = FruitGardener.factory("Apple");
            assertTrue(fruit instanceof Apple);

            fruit = FruitGardener.factory("Grape");
            assertTrue(fruit instanceof Grape);

            fruit = FruitGardener.factory("Strawberry");
            assertTrue(fruit instanceof Strawberry);

            FruitGardener.factory("something");

        } catch (Exception e) {
            assertTrue(e instanceof BadFruitException);
        }
    }
}
```

### 12.3 简单工厂模式的结构

<p>简单工厂模式是<kbd>类</kbd>的创建模式，这个模式的一般性结构如下图所示：</p>

<img src="./image/12.03.001.svg"/>

#### 12.3.1 角色与结构

<p>简单工厂模式就是由一个工厂类根据传入的参量决定创建出哪一种产品类的示例。</p>
<p>下面以一个示意性的实现为例说明简单工厂模式的结构。</p>
<p>如下图所示：</p>

<img src="./image/12.03.002.svg"/>

<pre>
concrete
英 [ˈkɒŋkriːt]
美 [ˈkɑːŋkriːt]  
n. 混凝土
adj. 混凝土制的;确实的，具体的(而非想象或猜测的);有形的;实在的
vt. 用混凝土覆盖
</pre>

<p>从上图可以看出，简单工厂模式涉及到以下三个角色：</p>

<table>
<tr>
<td>工厂类（Creator）角色</td>
<td>
担任这个角色的是工厂方法模式的核心，含有与应用紧密相关的业务逻辑。</br>
工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。
</td>
</tr>
<tr>
<td>抽象产品（Product）角色</td>
<td>
担任这个角色的类是由工厂方法模式所创建的对象的父类，或他们共同拥有的接口。</br>
抽象产品角色可以用一个Java接口或者Java抽象类实现。
</td>
</tr>
<tr>
<td>具体产品（Concrete Product）角色</td>
<td>工厂方法模式所创建的任何对象都是这个角色的实例，具体产品角色由一个Java类实现。</td>
</tr>
</table>

#### 12.3.2 源代码

<kbd>Product.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public interface Product {
}
```

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public class ConcreteProduct implements Product {
    public ConcreteProduct() {
    }
}
```

<kbd>Creator.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

public class Creator {
    /*
     * 静态工厂方法
     * */
    public static Product factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>CreatorTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example2;

import junit.framework.TestCase;
import org.junit.Test;

public class CreatorTest extends TestCase {
    @Test
    public void testFactory() {
        Product product = Creator.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

### 12.4 简单工厂模式的实现

#### 12.4.1 多层次的产品结构

<p>真实系统中，产品具有复杂的等级结构</p>
<p>如下，树形结构中具有多个抽象产品和具体产品类</p>
<img src="./image/12.04.001.svg"/>
<p>如示例，简单工厂模式采用以不变应万变的策略，一律使用同一个工厂类。</p>
<p>优点：设计简单，产品类的等级结构不会反映到工厂类中来，从而产品的等级结构的变化也不会影响到工厂类。</p>
<p>缺点：增加新的产品时也需要修改工厂类。</p>

#### 12.4.2 使用Java接口或者Java抽象类

<p>如果模式所生产的具体产品类之间没有共同的业务逻辑，那么抽象产品角色可以是一个Java接口</p>
<p>反之，抽象产品角色应该是一个抽象类，这些公有的业务逻辑应统一放到抽象类中。</p>
<img src="./image/12.04.002.svg"/>

#### 12.4.3 多个工厂方法

<p>工厂类可以有多个工厂方法，分别负责创建不同的产品对象。</p>
<p>比如：java.text.DateFormat类是其子类的工厂类，并且提供了多个静态工厂方法。</p>

#### 12.4.4 抽象产品角色的省略

<p>如果系统仅有一个具体产品角色，可以省略抽象产品角色。</p>
<p>类图如下：</p>
<img src="./image/12.04.003.svg"/>
<p>示例代码如下：</p>

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

public class ConcreteProduct {
    public ConcreteProduct() {
    }
}
```

<kbd>Creator.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

public class Creator {
    /*
    * 静态工厂方法
    * */
    public static ConcreteProduct factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>CreatorTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example3;

import junit.framework.TestCase;
import org.junit.Test;

public class CreatorTest extends TestCase {
    @Test
    public void testFactory() {
        ConcreteProduct product = Creator.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

#### 12.4.5 工厂角色与抽象产品角色合并

<p>某些情况下，工厂角色可以由抽象产品角色扮演。</p>
<p>典型的应用就是java.text.DateFormat类，一个抽象产品类，同时也是子类的工厂。</p>
<img src="./image/12.04.004.svg"/>
<p></p>

#### 12.4.6 三个角色全部合并

<p>如果抽象产品角色已经被省略，那工厂角色就可以与具体产品角色合并。</p>
<p>即，一个产品类为自身的工厂。</p>
<img src="./image/12.04.005.svg"/>
<p>三个原本独立的角色：抽象产品，具体产品，工厂类都已经合并为一个类，这个类自行创建自己的实例，代码如下：</p>

<kbd>ConcreteProduct.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example4;

public class ConcreteProduct {
    public ConcreteProduct() {
    }

    /*
    * 静态工厂方法
    * */
    public static ConcreteProduct factory() {
        return new ConcreteProduct();
    }
}
```

<kbd>ConcreteProductTest.java</kbd>

```java
package com.benson.note.pij.construct.simplefactory.example4;

import junit.framework.TestCase;
import org.junit.Test;

public class ConcreteProductTest extends TestCase {
    @Test
    public void testFactory() {
        ConcreteProduct product = ConcreteProduct.factory();
        assertTrue(product instanceof ConcreteProduct);
    }
}
```

#### 12.4.7 产品对象的循环使用和登记式的工厂方法

<p>简单工厂模式是一个非常基本的设计模式，因此它会在较为复杂的设计模式中出现。本章之前给出的示例，工厂方法总是简单的调用产品类的构造子来创建新的产品实例，然后返回给客户端，而在实际场景中，工厂方法做的事情可以相当复杂。</p>
<p>在本书所讨论的所有设计模式中，单例模式与多例模式是建立在简单工厂模式的基础上的，并且要求工厂方法具有特殊逻辑，以便能够循环使用产品的实例。</p>
<p>很多情况下，产品对象可以循环使用。换言之，工厂方法可以奴化您使用自己已经创建出来的对象，而不是每次一次都创建新的产品对象。工厂方法可以通过登记他所创建的产品对象来达到循环使用产品对象的目的。</p>
<p>如果工厂方法总是循环使用同一个产品对象，那么这个工厂对象可以使用一个属性来存储这个产品对象。每次客户端调用工厂方法时，工厂方法总是提供这同一个对象。单例模式中就是这样，单例类提供一个静态工厂方法，向外界提供一个唯一的单例类示例。</p>
<p>如果工厂方法永远循环使用固定数目的一些产品对象，而且这些产品对象的数目并大的话，可以使用一些私有属性存储这些产品对象的引用。比如：一个永远只提供一个产品对象的工厂对象可以使用一个静态变量存储这个产品对象的引用。</p>
<p>相反，如果工厂方法使用数目不确定，或者数目较大的一些产品对象的话，使用属性存储这些产品对象的引用就不方便了。这时，就应该使用集合对象存储对产品对象的引用。</p>
<p>无论使用哪种方法，工厂对象都能做到循环使用它所创建的对象。循环的逻辑可能是基于这些产品类的内部状态，比如某一种产品的对象只创建一个，让所有需要处于这个状态上的产品对象的客户端共享这一个实例。</p>

### 12.5 简单工厂模式与其他模式的关系

#### 12.5.1 单例模式

<p>单例模式使用了简单工厂模式。</p>
<p></p>
<p></p>


#### 12.5.2 多例模式



#### 12.5.3 备忘录模式



#### 12.5.4 MVC模式



### 12.6 简单工厂模式的优点和缺点



### 12.7 简单工厂模式在Java中的应用



### 12.8 女娲抟(tuan2)土造人



## 第13章 工厂方法（Factory Method）模式



### 13.1 引言



### 13.2 工厂方法模式的结构



### 13.3 工厂方法模式在农场系统中的实现



### 13.4 关于工厂方法模式的实现



### 13.5 Java语言中工厂方法模式的例子



### 13.6 工厂方法模式与其他模式的关系



### 13.7 女娲举绳造人



### 13.8 其他的例子



## 第14章 抽象工厂（Abstract Factory）模式



### 14.1 引言



### 14.2 问题



### 14.3 抽象工厂模式的结构



### 14.4 在什么情形下应当使用抽象工厂模式



### 14.5 抽象工厂模式在农场系统中的实现



### 14.6 抽象工厂模式的另一个例子



### 14.7 “开 - 闭”原则



### 14.8 相关的模式与模式的实现



### 14.9 女娲造万物的故事



### 14.10 附录：JavaAWT的Peer架构与抽象工厂模式



## 第15章 单例（Singleton）模式



### 15.1 引言



### 15.2 单例模式的结构



### 15.3 在什么情况下使用单例模式



### 15.4 单例类的状态



### 15.5 一个实用的例子：属性管理器



### 15.6 Java语言中的单例模式



### 15.7 专题：不完全的单例类



### 15.8 相关模式



### 15.9 附录：双重检查成例的研究



### 15.10 给读者的一点建议



## 第16章 专题：单例模式与MX记录



### 16.1 问题与解决方案



### 16.2 目录服务与MX记录



### 16.3 JNDI架构介绍



### 16.4 如何使用JNDI编程



### 16.5 系统设计



### 16.6 讨论



## 第17章 专题：多例（Multiton）模式与多语言支持



### 17.1 引言



### 17.2 多例模式



### 17.3 多语言项目的设计



## 第18章 专题：序列键生成器与单例及多例模式



### 18.1 问题



### 18.2 将单例模式应用到系统设计中



### 18.3 想多例模式应用到系统设计中



### 18.4 讨论



## 第19章 建造（Builder）模式



### 19.1 引言



### 19.2 建造模式的结构



### 19.3 建造模式的活动序列



### 19.4 建造模式的实现



### 19.5 众神造人的神话故事



### 19.6 JavaMail中的建造模式



### 19.7 一个发送邮件的例子



### 19.8 在什么情况下使用建造模式



### 19.9 建造模式与其他模式的关系



## 第20章 原始模型（Prototype）模式



### 20.1 引言



### 20.2 变量、对象以及对象的引用



### 20.3 Java对象的复制



### 20.4 原始模型模式的结构



### 20.5 模式的实现：深复制和浅复制



### 20.6 孙大圣的身外身法术



### 20.7 在什么情况下使用原始模型模式



### 20.8 原始模型模式的优点和缺点



### 20.9 原始模型模式与其他模式的关系



## 第21章 专题：JavaBean的“冷藏”和“解冻”



### 21.1 什么是“冷藏”和“解冻”



### 21.2 什么可以“冷藏”



### 21.3 Beans.instantiate()方法



### 21.4 怎样在JSP中使用Beans.instantiate()方法



### 21.5 与装饰模式的关系



# 第四部分



## 第22章 适配器（Adapter）模式



### 22.1 引言



### 22.2 类的适配器模式的结构



### 22.3 类的适配器模式的效果



### 22.4 对象的适配器模式的结构



### 22.5 在什么情况下使用适配器模式



### 22.6 Iterator与Enumeration



### 22.7 利用适配器模式指方为圆



### 22.8 适配器模式在架构层次上的应用



### 22.9 关于模式实现的讨论



### 22.10 适配器模式与相关的模式



## 第23章 缺省适配（Default Adapter）模式



### 23.1 鲁智深的故事



### 23.2 WindowAdapter是缺省适配模式



### 23.3 模式的结构



### 23.4 在什么情况下使用本模式



### 23.5 模式的实现



### 23.6 J2SE中的缺省适配模式



### 23.7 一个例子



## 第24章 专题：XMLProperties与适配器模式



### 24.1 引言



### 24.2 SAX2浏览器



### 24.3 开始XMLProperties项目



## 第25章 合成（Composite）模式



### 25.1 对象的树结构



### 25.2 介绍合成模式



### 25.3 安全式和透明式的合成模式



### 25.4 安全式的合成模式的结构



### 25.5 透明式的合成模式的结构



### 25.6 合成模式的实现



### 25.7 道士的故事



### 25.8 一个绘图的例子



### 25.9 AWT库中的例子



### 25.10 合成模式与其他模式的关系



## 第26章 装饰（Decorator）模式



### 26.1 引言



### 26.2 装饰模式的结构



### 26.3 装饰模式应当在什么情况下使用



### 26.4 孙大圣的故事



### 26.5 使用装饰模式的优点和缺点



### 26.6 模式实现的讨论



### 26.7 装饰模式与其他模式的关系



### 26.8 实例：GrepReader



### 26.9 一个例子：发票系统



### 26.10 附录：关于适配器模式与装饰模式的对话



## 第27章 专题：设计模式在Java I/O库中的应用



### 27.1 引言



### 27.2 Java I/O库的设计原则



### 27.3 装饰模式的应用



### 27.4 半透明的装饰模式



### 27.5 适配器模式的应用



### 27.6 从byte流到char流的适配



## 第28章 代理（Proxy）模式



### 28.1 引言



### 28.2 代理的种类



### 28.3 代理模式的结构



### 28.4 代理模式的时序



### 28.5 Java 2.0对代理模式的支持



### 28.6 高老庄悟空降八戒



### 28.7 代理模式的优点和缺点



### 28.8 代理模式的实现



### 28.9 代理模式与其他模式的关系



## 第29章 专题：智能引用代理



### 29.1 问题



### 29.2 系统设计



### 29.3 系统的时序



### 29.4 系统的源代码



## 第30章 专题：虚拟代理的例子



### 30.1 问题



### 30.2 系统的要求



### 30.3 系统的设计



### 30.4 系统的时序



### 30.5 系统的源代码



## 第31章 享元模式（Flyweight Pattern）



### 31.1 引言



### 31.2 单纯享元模式的结构



### 31.3 复合享元模式的结构



### 31.4 模式的实现



### 31.5 一个咖啡摊的例子



### 31.6 咖啡屋的例子



### 31.7 享元模式应当在什么情况下使用



### 31.8 从代码重构的角度看享元模式



### 31.9 享元模式的优点和缺点



### 31.10 相关的模式



## 第32章 门面（Facade）模式



### 32.1 引言



### 32.2 门面模式的结构



### 32.3 门面模式的实现



### 32.4 在什么情况下使用门面模式



### 32.5 迪米特法则（LoD）



### 32.6 一个例子



### 32.7 使用门面模式的设计



### 32.8 Session门面模式



## 第33章 桥梁（Bridge）模式



### 33.1 引言



### 33.2 桥梁模式的结构



### 33.3 Java语言中的Peer架构



### 33.4 驱动器和JDBC驱动器



### 33.5 从重构的角度考察



### 33.6 桥梁模式和其他模式的关系



### 33.7 八戒“转世投胎”的故事



### 33.8 关于桥梁模式的实现



### 33.9 在什么情况下应当使用桥梁模式



# 第五部分



## 第34章 不变（Immutable）模式



### 34.1 引言



### 34.2 不变模式的结构和实现



### 34.3 不变模式在Java语言中的应用



### 34.4 不变模式的优点和缺点



### 34.5 不变模式与享元模式的关系



### 34.6 一个例子：复数类



## 第35章 策略（Strategy）模式



### 35.1 引言



### 35.2 模式的实现



### 35.3 Java语言内部的例子



### 35.4 排序策略系统



### 35.5 一个例子：图书折扣的计算



### 35.6 在什么情况下应当使用策略模式



### 35.7 策略模式的优点和缺点



### 35.8 策略模式与其他模式的关系



### 35.9 设计原则的讨论



### 35.10 诸葛亮的锦囊妙计



## 第36章 模板方法（Template Method）模式



### 36.1 引言



### 36.2 模板方法模式的结构



### 36.3 “好莱坞原则”



### 36.4 一个例子



### 36.5 继承作为复用的工具



### 36.6 Java语言里面使用过的模板方法模式



### 36.7 模板方法模式中的方法



### 36.8 模板方法模式在代码重构中的应用



### 36.9 重构的原则



### 36.10 西天取经的八十一难



## 第37章 专题：Servlet技术中的模式



### 37.1 Servlet技术介绍



### 37.2 模板方法模式的使用



### 37.3 观察者模式的应用



## 第38章 观察者（Observer）模式



### 38.1 引言



### 38.2 观察者模式的结构



### 38.3 另一种实现方案



### 38.4 Java语言提供的对观察者模式的支持



### 38.5 菩萨的守瓶龟



### 38.6 Java中的DEM事件机制



### 38.7 观察者模式与其他模式的关系



## 第39章 专题：观察者模式与AWT中的事件处理



### 39.1 引言



### 39.2 DEM的结构



## 第40章 专题：观察者热模式与SAX2浏览器



### 40.1 引言



### 40.2 SAX2是怎么工作的



### 40.3 ContentHandler接口



### 40.4 怎样实现ContentHandler接口



### 40.5 怎样使用ContentHandler



### 40.6 缺省适配模式与DefaultHandler



### 40.7 简单工厂模式的应用



## 第41章 专题：观察者模式与Swing定时器



### 41.1 为什么需要定时器



### 41.2 Utility定时器与Swing定时器的区别



### 41.3 使用Swing定时器的方法



### 41.4 观察者模式的应用



### 41.5 单例模式的应用



## 第42章 专题：MVC模式与用户输入数据检查



### 42.1 什么是MVC模式



### 42.2 MVC是架构模式



### 42.3 MVC模式在J2EE技术中的应用



### 42.4 从代码重构的角度查看



### 42.5 用户输入检查与MVC模式



### 42.6 SQL注射



## 第43章 迭代子（Iterator）模式



### 43.1 引言



### 43.2 迭代子模式的结构



### 43.3 迭代子模式的实现



### 43.4 迭代子模式的优点和缺点



### 43.5 一个例子



### 43.6 迭代子模式与其他模式的关系



## 第44章 专题：Java对迭代子模式的支持



### 44.1 Java聚集



### 44.2 Java聚集中的迭代子



### 44.3 java.util.Iterator接口



### 44.4 Java迭代子接口ListIterator



### 44.5 Enumeration与Iterator



### 44.6 其他相关模式



## 第45章 责任链（Chain of Responsibility）模式



### 45.1 从击鼓传花谈起



### 45.2 责任链模式的结构



### 45.3 纯的与不纯的责任链模式



### 45.4 Java 1.0版本的AWT事件处理机制



### 45.5 『红楼梦』中击鼓传花的故事



### 45.6 Java系统的解



### 45.7 责任链模式的实现



### 45.8 对象的树结构



### 45.9 DHTML中的事件处理



### 45.10 责任链模式与其他模式的关系



## 第46章 专题：定时器与击鼓传花



### 46.1 线程



### 46.2 定时器



### 46.3 击鼓传花



## 第47章 命令（Command）模式



### 47.1 引言



### 47.2 命令模式的结构



### 47.3 玉帝传美猴王上天



### 47.4 Java语言内的例子：AWT的事件处理



### 47.5 一个例子：创世纪系统



### 47.6 一个例子：AudioPlayer系统



### 47.7 增加宏命令功能



### 47.8 模式的实现



### 47.9 在什么情况下应当使用命令模式



### 47.10 使用命令模式的优点和缺点



### 47.10 命令模式与其他模式的关系



## 第48章 专题：Swing库中的命令撤销和恢复



### 48.1 在视窗系统中使用命令模式



### 48.2 Swing的基本撤销功能



### 48.3 一休论禅的文字框



## 第49章 备忘录（Memento）模式



### 49.1 备忘录模式的结构



### 49.2 备忘录模式的白箱实现



### 49.3 双重接口及其在Java语言中的实现



### 49.4 备忘录模式的黑箱实现



### 49.5 责任人角色的增强



### 49.6 备忘录模式与多重检查点



### 49.7 “自述历史”模式



### 49.8 “假如”协议模式



### 49.9 备忘录模式与其他模式的关系



### 49.10 备忘录模式的应用



### 49.11 使用备忘录模式的优点和缺点



### 49.12 观世音甘泉活树的故事



## 第50章 状态（State）模式



### 50.1 引言



### 50.2 状态模式的结构



### 50.3 曾侯乙编钟的描述



### 50.4 状态模式的效果



### 50.5 在什么情况下使用状态模式



### 50.6 关于模式实现的讨论



### 50.7 一个状态模式的应用例子：TCP



### 50.8 状态模式在绘图软件中的应用



### 50.9 用户登录子系统



### 50.10 状态模式与策略模式的区别



## 第51章 专题：崂山道士与状态模式



### 51.1 有状态的墙



### 51.2 异常逻辑



### 51.3 从代码重构的角度考察



## 第52章 专题：单分派和多分派



### 52.1 分派的概念



### 52.2 双重分派



### 52.3 未来的Java语言



## 第53章 访问者（Visitor）模式



### 53.1 引言



### 53.2 访问者模式的结构



### 53.3 系统的时序图



### 53.4 在什么情况下应当使用访问者模式



### 53.5 使用访问者模式的优点和缺点



### 53.6 访问者模式的实现



### 53.7 电脑专卖系统：问题与对象



### 53.8 电脑专卖系统的访问者模式设计



### 53.9 与访问者模式有关的模式



## 第54章 解释器（Interpreter）模式



### 54.1 引言



### 54.2 解释器模式的结构



### 54.3 一个示意性的实现



### 54.4 有关模式



## 第55章 调停者（Mediator）模式



### 55.1 引言



### 55.2 调停者模式的结构



### 55.3 调停者模式的实现



### 55.4 迪米特法则（LoD）



### 55.5 调停者模式的优点和缺点



### 55.6 调停者模式的使用条件



### 55.7 与调停者模式有关的模式



# 附录



## 附录A 设计模式一览表



### A.1 创建模式



### A.2 结构模式



### A.3 行为模式



## 附录B UML图标及Java实现



### 一览表



## 附录C 中英术语对照表


